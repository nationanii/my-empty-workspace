#!/bin/bash
set -euo pipefail
# =====================================================================
# TinyCore Auto Windows Deployer v8-dpct-hostnet
# Network: Passthrough từ DPCT host (tự động lấy từ host)
# - Không cấu hình network thủ công
# - Sử dụng network bridge/passthrough của host
# - DHCP tự động từ network host
# =====================================================================

# === USER CONFIG =====================================================
GZ_LINK="https://148.100.76.25:3923/WindowsCustom.gz"
DISCORD_WEBHOOK="https://discord.com/api/webhooks/1460967132761423913/8cPQaQCrlvc-0CWC7VpM30bKr1ulMPUrCFZAUr7r06VPqFkbgCvCRbuyde_Ffc-0joff"
SWAP_URL="https://raw.githubusercontent.com/lt4c/stuff/refs/heads/main/grubsdbuefiwin.gz"

# === TINYCORE CONFIGURATION ==========================================
TCE_VERSION="14.x"
ARCH="x86_64"
TCE_MIRROR="http://tinycorelinux.net"
BOOT_DIR="/boot/tinycore"
WORKDIR="/tmp/tinycore_initrd"
KERNEL_URL="$TCE_MIRROR/$TCE_VERSION/$ARCH/release/distribution_files/vmlinuz64"
INITRD_URL="$TCE_MIRROR/$TCE_VERSION/$ARCH/release/distribution_files/corepure64.gz"
KERNEL_PATH="$BOOT_DIR/vmlinuz64"
INITRD_PATH="$BOOT_DIR/corepure64.gz"
INITRD_PATCHED="$BOOT_DIR/corepure64-v8-dpct-hostnet.gz"
BUSYBOX_URL="https://raw.githubusercontent.com/lt4c/stuff/refs/heads/main/busybox"

# === ENVIRONMENT SETUP ===============================================
export DEBIAN_FRONTEND=noninteractive
export NEEDRESTART_MODE=a
echo 'kexec-tools kexec-tools/load_kexec boolean true' | debconf-set-selections

# === HELPER FUNCTIONS ================================================
log_msg() {
    echo "[$(date +'%H:%M:%S')] $1"
}

check_command() {
    if ! command -v "$1" &> /dev/null; then
        log_msg "ERROR: Required command '$1' not found"
        return 1
    fi
    return 0
}

download_with_retry() {
    local url="$1"
    local output="$2"
    local max_attempts="${3:-3}"
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        log_msg "Downloading $(basename "$output") (attempt $attempt/$max_attempts)..."
        if wget -q -O "$output" "$url"; then
            if [ -s "$output" ]; then
                log_msg "Download successful: $(basename "$output")"
                return 0
            fi
        fi
        attempt=$((attempt + 1))
        [ $attempt -le $max_attempts ] && sleep 2
    done
    
    log_msg "ERROR: Failed to download after $max_attempts attempts"
    return 1
}

# === INSTALLATION PHASE ==============================================
log_msg "=== Phase 1/6: Installing dependencies ==="
apt-get -y -qq update
apt-get -y -qq install wget curl gzip cpio kexec-tools parted gdisk \
    ca-certificates util-linux iproute2 --no-install-recommends

for cmd in wget curl gzip cpio kexec parted gdisk ip; do
    check_command "$cmd" || exit 1
done

mkdir -p "$BOOT_DIR" "$WORKDIR"
log_msg "Directories created: $BOOT_DIR, $WORKDIR"

# === DOWNLOAD PHASE ==================================================
log_msg "=== Phase 2/6: Fetching TinyCore artifacts ==="
download_with_retry "$KERNEL_URL" "$KERNEL_PATH" || exit 1
download_with_retry "$INITRD_URL" "$INITRD_PATH" || exit 1

# Validate downloads
if [ ! -s "$KERNEL_PATH" ] || [ ! -s "$INITRD_PATH" ]; then
    log_msg "ERROR: Downloaded files are empty or missing"
    exit 1
fi
log_msg "Kernel size: $(du -h "$KERNEL_PATH" | cut -f1)"
log_msg "Initrd size: $(du -h "$INITRD_PATH" | cut -f1)"

# === INITRD UNPACKING ================================================
log_msg "=== Phase 3/6: Unpacking initrd ==="
cd "$WORKDIR"
if ! gzip -dc "$INITRD_PATH" | cpio -idm 2>/dev/null; then
    log_msg "ERROR: Failed to unpack initrd"
    exit 1
fi
log_msg "Initrd unpacked successfully"

# === SCRIPT INJECTION ================================================
log_msg "=== Phase 4/6: Injecting deployment script ==="
mkdir -p "$WORKDIR/srv" "$WORKDIR/opt"
echo "TinyCore v8-dpct-hostnet: Network from host passthrough" > "$WORKDIR/srv/lab"

log_msg "Downloading BusyBox..."
download_with_retry "$BUSYBOX_URL" "$WORKDIR/srv/busybox" || exit 1
chmod +x "$WORKDIR/srv/busybox"

cat > "$WORKDIR/opt/bootlocal.sh" <<'BOOTLOCAL_SCRIPT'
#!/bin/sh
# =============================================================================
# TinyCore Windows Deployment Script v8-dpct-hostnet
# Network: Passthrough từ DPCT host (bridge tự động)
# =============================================================================
IMAGE_URL="__TC_GZ_LINK__"
DISCORD_WEBHOOK="__TC_DISCORD__"
SWAP_URL="__TC_SWAP_URL__"
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# === UTILITIES =======================================================
safe_echo() { echo "$1" | sed 's/"/\\"/g; s/\\/\\\\/g'; }

post_discord() {
  [ -z "$DISCORD_WEBHOOK" ] && return 0
  local msg="$1"
  echo "$msg" | awk -v max=1900 '{
    line=$0
    while(length(line)>max){
      print substr(line,1,max)
      line=substr(line,max+1)
    }
    if(length(line)>0) print line
  }' | while read -r chunk; do
    [ -z "$chunk" ] && continue
    curl -m 8 -sS -H "Content-Type: application/json" \
      -d "{\"content\":\"\`\`\`$(safe_echo "$chunk")\`\`\`\"}" \
      "$DISCORD_WEBHOOK" >/dev/null 2>&1 || true
    sleep 0.3
  done
}

log() {
  local msg="[$(date +'%H:%M:%S')] $1"
  echo "$msg" | tee -a /srv/lab
  post_discord "$msg"
}

# === HTTP SERVER SETUP ===============================================
[ -d /srv ] || mkdir -p /srv
touch /srv/lab
chmod 644 /srv/lab
chmod +x /srv/busybox 2>/dev/null || true

if /srv/busybox httpd -p 80 -h /srv 2>/dev/null; then
  log "✓ HTTP server started on port 80"
else
  log "⚠ Failed to start HTTP server"
fi

# Heartbeat process
( while true; do 
    echo "[HEARTBEAT] $(date +'%Y-%m-%d %H:%M:%S')" >> /srv/lab
    sleep 10
  done ) &

log "=========================================="
log "TinyCore Deployer v8-dpct-hostnet"
log "Network: Host passthrough/bridge"
log "=========================================="
log "System: $(uname -sr)"
log "Memory: $(free -m | awk 'NR==2{printf "%sMB/%sMB (%.0f%%)", $3,$2,$3*100/$2}')"
log "Cmdline: $(cat /proc/cmdline)"

# === PACKAGE INSTALLATION ============================================
log "Installing required packages..."
PACKAGES="ca-certificates.tcz openssl.tcz curl.tcz openssh.tcz parted.tcz gdisk.tcz"

for pkg in $PACKAGES; do
  log "Loading $pkg..."
  if su tc -c "tce-load -wi $pkg" >> /srv/lab 2>&1; then
    log "✓ $pkg loaded"
  else
    log "⚠ Warning: $pkg load failed (non-fatal)"
  fi
  sleep 1
done

# Start SSH
if /usr/local/etc/init.d/openssh start >/dev/null 2>&1; then
  log "✓ SSH service started"
fi

# === NETWORK FROM HOST (PASSTHROUGH) =================================
log "Network configuration: Using host passthrough/bridge"

# Kill existing DHCP clients
killall -q udhcpc 2>/dev/null || true
sleep 2

# Detect all network interfaces
ALL_IFACES="$(ls /sys/class/net 2>/dev/null | grep -v '^lo$' | tr '\n' ' ')"
log "Available interfaces: $ALL_IFACES"

NETWORK_UP=0
ACTIVE_NIC=""

# Bring up all real interfaces and wait for host network
for nic in $ALL_IFACES; do
  # Skip virtual interfaces
  case "$nic" in 
    dummy*|tun*|tap*|sit*|veth*|virbr*|br-*|docker*) 
      continue 
    ;;
  esac
  
  log "Initializing $nic..."
  
  # Bring interface up
  ip link set "$nic" up 2>/dev/null
  sleep 2
  
  # Check if interface already has IP (from host bridge)
  if ip -4 addr show dev "$nic" | grep -q 'inet '; then
    IP_INFO="$(ip -4 addr show dev "$nic" | grep 'inet ' | awk '{print $2}')"
    log "✓ $nic already has IP from host: $IP_INFO"
    NETWORK_UP=1
    ACTIVE_NIC="$nic"
    break
  fi
  
  # Try DHCP (host bridge might provide DHCP)
  log "Requesting DHCP on $nic (host bridge mode)..."
  udhcpc -b -R -n -q -t 3 -T 2 -A 5 -p "/var/run/udhcpc-$nic.pid" -i "$nic" >> /srv/lab 2>&1 || true
  
  # Wait for IP (up to 20 seconds)
  for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20; do
    if ip -4 addr show dev "$nic" | grep -q 'inet '; then
      IP_INFO="$(ip -4 addr show dev "$nic" | grep 'inet ' | awk '{print $2}')"
      log "✓ IPv4 acquired on $nic: $IP_INFO"
      NETWORK_UP=1
      ACTIVE_NIC="$nic"
      break 2
    fi
    sleep 1
  done
  
  log "⚠ No DHCP response on $nic"
done

# Display network status
if [ "$NETWORK_UP" -eq 1 ]; then
  log "=========================================="
  log "Network Status: READY"
  log "=========================================="
  ip -4 addr show dev "$ACTIVE_NIC" | grep 'inet ' | sed 's/^/  /' >> /srv/lab
  ip route show | sed 's/^/  Route: /' >> /srv/lab
  cat /etc/resolv.conf | grep nameserver | sed 's/^/  /' >> /srv/lab
  
  # Test connectivity
  log "Testing network connectivity..."
  if ping -c 2 -W 3 1.1.1.1 >/dev/null 2>&1; then
    log "✓ Internet connectivity OK"
  else
    log "⚠ No internet connectivity (but continuing...)"
  fi
else
  log "=========================================="
  log "⚠ WARNING: No network configured"
  log "=========================================="
  log "This might be normal if:"
  log "  - Host is still configuring network"
  log "  - Network bridge is not ready yet"
  log "  - Using custom network setup"
  log ""
  log "Waiting 10s for host network to stabilize..."
  sleep 10
  
  # Last attempt: check all interfaces again
  for nic in $ALL_IFACES; do
    case "$nic" in dummy*|tun*|tap*|sit*|veth*|virbr*|br-*|docker*) continue;; esac
    if ip -4 addr show dev "$nic" | grep -q 'inet '; then
      IP_INFO="$(ip -4 addr show dev "$nic" | grep 'inet ' | awk '{print $2}')"
      log "✓ Found late IP on $nic: $IP_INFO"
      NETWORK_UP=1
      ACTIVE_NIC="$nic"
      break
    fi
  done
  
  if [ "$NETWORK_UP" -eq 0 ]; then
    log "⚠ Still no network, deployment may fail"
  fi
fi

# === DISK DETECTION ==================================================
log "Detecting target disk..."

# Preferred disk order (avoid boot disk)
TARGET=""
for disk in /dev/sdb /dev/vdb /dev/nvme1n1 /dev/sda /dev/vda /dev/nvme0n1; do
  if [ -b "$disk" ]; then
    TARGET="$disk"
    log "Found candidate: $disk"
    break
  fi
done

# Fallback: first disk from lsblk
if [ -z "$TARGET" ]; then
  TARGET="$(lsblk -dno NAME,TYPE 2>/dev/null | awk '$2=="disk"{print "/dev/"$1; exit}')"
fi

if [ -z "$TARGET" ] || [ ! -b "$TARGET" ]; then
  log "✗ ERROR: No suitable disk found"
  log "Rebooting in 5 seconds..."
  sleep 5
  reboot -f
fi

log "Target disk: $TARGET"
lsblk "$TARGET" -o NAME,SIZE,TYPE,FSTYPE,MOUNTPOINT 2>/dev/null | sed 's/^/  /' >> /srv/lab

# Get disk size for validation
DISK_SIZE_GB="$(lsblk -bno SIZE "$TARGET" 2>/dev/null | awk '{printf "%.1f", $1/1024/1024/1024}')"
log "Target disk size: ${DISK_SIZE_GB}GB"

# === UNMOUNT PARTITIONS ==============================================
log "Unmounting all partitions on $TARGET..."
UNMOUNT_COUNT=0
for mnt in $(mount | awk -v t="$TARGET" '$1 ~ t {print $3}'); do
  if umount -f "$mnt" 2>/dev/null; then
    log "✓ Unmounted: $mnt"
    UNMOUNT_COUNT=$((UNMOUNT_COUNT + 1))
  fi
done
[ $UNMOUNT_COUNT -gt 0 ] && log "Unmounted $UNMOUNT_COUNT partition(s)"

sync
sleep 2

# === BOOT DISK DETECTION =============================================
BOOT_DEVICE="$(readlink -f /dev/root 2>/dev/null || echo '')"
if [ -n "$BOOT_DEVICE" ]; then
  BOOTDISK="$(lsblk -no PKNAME "$BOOT_DEVICE" 2>/dev/null | sed 's#^#/dev/#')"
else
  BOOTDISK="/dev/sda"
fi
[ -z "$BOOTDISK" ] && BOOTDISK="/dev/sda"

log "Boot disk detected: $BOOTDISK"
if [ "$BOOTDISK" = "$TARGET" ]; then
  log "⚠ WARNING: Target is boot disk - deployment will overwrite boot!"
fi

# === IMAGE DEPLOYMENT ================================================
log "=========================================="
log "Starting image deployment"
log "=========================================="
log "Source: $IMAGE_URL"
log "Target: $TARGET"

# Check redirect chain
log "Verifying download URL..."
wget --no-check-certificate --max-redirect=20 -S --spider "$IMAGE_URL" >> /srv/lab 2>&1 || true

# Stream deployment: wget | gunzip | dd
log "Starting streaming deployment..."
log "Pipeline: wget -> gunzip -> dd"

START_TIME="$(date +%s)"

(
  wget --no-check-certificate --progress=dot:giga -O- "$IMAGE_URL" 2>&1 \
  | tee >(grep -o '[0-9]*%' | tail -1 >> /srv/wget_progress) \
  | gunzip -c \
  | dd of="$TARGET" bs=64M conv=fsync oflag=direct 2>&1 \
  | tee -a /srv/lab
) &

PIPE_PID=$!
log "Deployment pipeline started (PID: $PIPE_PID)"

# Monitor progress
LAST_OFFSET=0
STALL_COUNT=0
CHECK_INTERVAL=5

while kill -0 "$PIPE_PID" 2>/dev/null; do
  ELAPSED=$(($(date +%s) - START_TIME))
  
  # Find dd process
  DD_PID="$(pidof dd 2>/dev/null | awk '{print $1}')"
  
  if [ -n "$DD_PID" ] && [ -r "/proc/$DD_PID/fdinfo/1" ]; then
    OFFSET="$(awk '/pos:/{print $2}' "/proc/$DD_PID/fdinfo/1" 2>/dev/null | head -n1)"
    [ -z "$OFFSET" ] && OFFSET=0
    
    OFFSET_MB=$((OFFSET / 1024 / 1024))
    SPEED_MBS=0
    
    if [ "$OFFSET" -gt "$LAST_OFFSET" ]; then
      DIFF=$((OFFSET - LAST_OFFSET))
      SPEED_MBS=$((DIFF / CHECK_INTERVAL / 1024 / 1024))
      STALL_COUNT=0
    else
      STALL_COUNT=$((STALL_COUNT + 1))
    fi
    
    log "Progress: ${OFFSET_MB}MB written | Speed: ${SPEED_MBS}MB/s | Time: ${ELAPSED}s"
    
    # Stall detection
    if [ "$STALL_COUNT" -gt 6 ]; then
      log "⚠ WARNING: No progress for $((STALL_COUNT * CHECK_INTERVAL))s"
    fi
    
    LAST_OFFSET="$OFFSET"
  else
    log "Deploying... (${ELAPSED}s elapsed)"
  fi
  
  sleep $CHECK_INTERVAL
done

# Check exit status
wait "$PIPE_PID"
RC=$?

TOTAL_TIME=$(($(date +%s) - START_TIME))

if [ "$RC" -ne 0 ]; then
  log "✗ ERROR: Deployment failed (exit code: $RC)"
  log "Total time: ${TOTAL_TIME}s"
  tail -100 /srv/lab >> /srv/lab
  sleep 5
  reboot -f
fi

sync
sleep 2

# Refresh partition table
partprobe "$TARGET" 2>/dev/null || true
sleep 1

log "✓ Deployment successful!"
log "Total time: ${TOTAL_TIME}s ($((TOTAL_TIME / 60))m $((TOTAL_TIME % 60))s)"
log "Final disk layout:"
lsblk "$TARGET" -o NAME,SIZE,TYPE,FSTYPE 2>/dev/null | sed 's/^/  /' >> /srv/lab

# === BOOTFIX =========================================================
if [ "$BOOTDISK" != "$TARGET" ] && [ -b "$BOOTDISK" ]; then
  log "Applying boot sector fix to $BOOTDISK..."
  
  if wget --no-check-certificate -O /tmp/grub.gz "$SWAP_URL" >> /srv/lab 2>&1; then
    if [ -s /tmp/grub.gz ]; then
      if gunzip -c /tmp/grub.gz | dd of="$BOOTDISK" bs=4M 2>> /srv/lab; then
        sync
        log "✓ Boot sector updated on $BOOTDISK"
      else
        log "⚠ Boot sector write failed"
      fi
    else
      log "⚠ Downloaded boot sector is empty"
    fi
  else
    log "⚠ Failed to download boot sector"
  fi
else
  log "Boot sector fix skipped (boot disk == target)"
fi

# === COMPLETION ======================================================
log "=========================================="
log "✓ All operations completed successfully"
log "=========================================="
sleep 3

log "Rebooting into deployed system..."
sleep 2
reboot -f
BOOTLOCAL_SCRIPT

# === VARIABLE INJECTION ==============================================
log_msg "Injecting configuration variables..."
sed -i "s#__TC_GZ_LINK__#${GZ_LINK}#g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s#__TC_DISCORD__#${DISCORD_WEBHOOK}#g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s#__TC_SWAP_URL__#${SWAP_URL}#g" "$WORKDIR/opt/bootlocal.sh"
chmod +x "$WORKDIR/opt/bootlocal.sh"

# Ensure autorun
if ! grep -q "/opt/bootlocal.sh" "$WORKDIR/etc/init.d/tc-config" 2>/dev/null; then
    echo "/opt/bootlocal.sh &" >> "$WORKDIR/etc/init.d/tc-config"
    log_msg "Added bootlocal.sh to tc-config"
fi

# === INITRD REPACKING ================================================
log_msg "=== Phase 5/6: Repacking initrd ==="
cd "$WORKDIR"
FILE_COUNT=$(find . | wc -l)
log_msg "Packing $FILE_COUNT files..."

if find . | cpio -o -H newc 2>/dev/null | gzip -9 > "$INITRD_PATCHED"; then
    PATCHED_SIZE=$(du -h "$INITRD_PATCHED" | cut -f1)
    log_msg "Initrd repacked successfully: $PATCHED_SIZE"
else
    log_msg "ERROR: Failed to repack initrd"
    exit 1
fi

# Validate patched initrd
if [ ! -s "$INITRD_PATCHED" ]; then
    log_msg "ERROR: Patched initrd is empty"
    exit 1
fi

# === KEXEC BOOT ======================================================
log_msg "=== Phase 6/6: Preparing kexec boot ==="

if ! check_command kexec; then
    log_msg "ERROR: kexec not available"
    exit 1
fi

CMDLINE="console=ttyS0 console=tty0 quiet loglevel=3"
log_msg "Loading kernel with kexec..."
log_msg "Kernel: $KERNEL_PATH"
log_msg "Initrd: $INITRD_PATCHED"
log_msg "Cmdline: $CMDLINE"

if kexec -l "$KERNEL_PATH" --initrd="$INITRD_PATCHED" --command-line="$CMDLINE"; then
    log_msg "Kernel loaded successfully"
else
    log_msg "ERROR: Failed to load kernel"
    exit 1
fi

# === FINAL SUMMARY ===================================================
echo ""
echo "===================================================================="
echo "  TinyCore Auto Deployer v8-dpct-hostnet"
echo "===================================================================="
echo "  ✓ Network: Host passthrough/bridge (tự động)"
echo "  ✓ No manual network configuration needed"
echo "  ✓ Enhanced error handling and validation"
echo "  ✓ Smart interface detection"
echo "  ✓ Progress monitoring with speed calculation"
echo "  ✓ Discord notifications enabled"
echo "===================================================================="
echo "  Booting TinyCore in 3 seconds..."
echo "===================================================================="
echo ""

sleep 3

log_msg "Executing kexec..."
kexec -e
