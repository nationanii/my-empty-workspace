#!/bin/bash
set -euo pipefail
# =====================================================================
# TinyCore Auto Windows Deployer v8-gotty-optimized
# IMPROVEMENTS:
# - GoTTY terminal sharing thay Discord webhook
# - K·∫ø th·ª´a network config t·ª´ host (IPv4 public)
# - Ch·ªçn target disk TR∆Ø·ªöC khi boot TinyCore (tr√°nh l·ªói ch·ªçn sai)
# - T·ªëi ∆∞u t·ªëc ƒë·ªô: song song download, gi·∫£m sleep, b·ªè packages kh√¥ng c·∫ßn
# =====================================================================

# === USER CONFIG =====================================================
GZ_LINK="http://148.100.76.25:3923/WindowsCustom.gz"   # Windows .img.gz URL
GOTTY_PORT="80"                 # GoTTY web terminal port
SWAP_URL="https://raw.githubusercontent.com/lt4c/stuff/refs/heads/main/grubsdbuefiwin.gz"

# === AUTO-DETECT TARGET DISK (TR∆Ø·ªöC KHI BOOT TINYCORE) ==============
echo "=========================================="
echo "üîç Detecting boot disk..."
echo "=========================================="

# L·∫•y boot disk (disk ch·ª©a root filesystem hi·ªán t·∫°i)
BOOT_DISK=$(lsblk -ndo PKNAME $(findmnt -n -o SOURCE /) 2>/dev/null | head -1)
if [ -z "$BOOT_DISK" ]; then
    # Fallback: t√¨m disk c√≥ mount point /
    BOOT_DISK=$(lsblk -ndo PKNAME $(mount | grep ' / ' | awk '{print $1}') 2>/dev/null | head -1)
fi
if [ -z "$BOOT_DISK" ]; then
    # Fallback cu·ªëi: t√¨m disk ƒë·∫ßu ti√™n
    BOOT_DISK=$(lsblk -ndo NAME,TYPE | awk '$2=="disk"{print $1; exit}')
fi

TARGET_DISK="/dev/$BOOT_DISK"

echo "üéØ Boot disk found: $TARGET_DISK"
echo ""

# Hi·ªÉn th·ªã th√¥ng tin chi ti·∫øt
echo "üìä Current disk layout:"
echo "----------------------------------------"
lsblk "$TARGET_DISK" -o NAME,SIZE,TYPE,FSTYPE,MOUNTPOINT,LABEL
echo "----------------------------------------"
echo ""

# Hi·ªÉn th·ªã t·∫•t c·∫£ disks ƒë·ªÉ user bi·∫øt
echo "üìÄ All available disks on system:"
lsblk -ndo NAME,SIZE,TYPE,MODEL | awk '$3=="disk"{print "  - /dev/"$1" ("$2") "$4}'
echo ""

echo "‚ÑπÔ∏è  This script will use the BOOT DISK: $TARGET_DISK"
echo "   (The disk where your current OS is running)"
echo ""
echo "‚ö†Ô∏è  WARNING: $TARGET_DISK will be completely wiped"
echo "   All data will be DESTROYED and replaced with Windows"
echo ""

# Bi·∫øn BOOT_DISK = TARGET_DISK (v√¨ ta ghi ƒë√® l√™n ch√≠nh disk ƒëang boot)
BOOT_DISK="$TARGET_DISK"

# === DETECT NETWORK CONFIG FROM HOST =================================
echo ""
echo "üåê Detecting network configuration..."

# L·∫•y interface ƒëang active (c√≥ default route)
HOST_NIC=$(ip route show default | head -1 | grep -oP 'dev \K\S+')
[ -z "$HOST_NIC" ] && HOST_NIC=$(ip -o link show | awk -F': ' '$2!="lo"{print $2; exit}')
[ -z "$HOST_NIC" ] && HOST_NIC="eth0"

# L·∫•y IP local (private/public)
HOST_IP=$(ip -4 addr show dev "$HOST_NIC" | grep -oP 'inet \K[\d.]+' | head -1)

# N·∫øu kh√¥ng c√≥ IP tr√™n NIC ƒë√≥, l·∫•y b·∫•t k·ª≥ IP n√†o (tr·ª´ 127.0.0.1)
if [ -z "$HOST_IP" ]; then
    HOST_IP=$(ip -4 addr show | grep -oP 'inet \K[\d.]+' | grep -v '^127\.' | head -1)
fi

# L·∫•y gateway
HOST_GW=$(ip route show default | head -1 | awk '{print $3}')
if [ -z "$HOST_GW" ]; then
    # Fallback: t√≠nh gateway t·ª´ IP (thay byte cu·ªëi = 1)
    HOST_GW="$(echo $HOST_IP | cut -d. -f1-3).1"
fi

# L·∫•y netmask/prefix (v√≠ d·ª•: 24 t·ª´ 10.0.1.179/24)
HOST_CIDR=$(ip -4 addr show dev "$HOST_NIC" | grep -oP 'inet [\d.]+/\K\d+' | head -1)
[ -z "$HOST_CIDR" ] && HOST_CIDR="24"

# L·∫•y nameserver
HOST_DNS=$(grep -m1 '^nameserver' /etc/resolv.conf | awk '{print $2}')
[ -z "$HOST_DNS" ] && HOST_DNS="1.1.1.1"

# === DETECT PUBLIC IP (cho GoTTY access) =============================
echo "üîç Detecting public IPv4..."
PUBLIC_IP=""

# Method 1: AWS EC2 metadata (nhanh nh·∫•t cho AWS)
PUBLIC_IP=$(timeout 2 curl -s http://169.254.169.254/latest/meta-data/public-ipv4 2>/dev/null)

# Method 2: ifconfig.me
[ -z "$PUBLIC_IP" ] && PUBLIC_IP=$(timeout 3 curl -s https://ifconfig.me 2>/dev/null)

# Method 3: icanhazip.com
[ -z "$PUBLIC_IP" ] && PUBLIC_IP=$(timeout 3 curl -s https://icanhazip.com 2>/dev/null)

# Method 4: api.ipify.org
[ -z "$PUBLIC_IP" ] && PUBLIC_IP=$(timeout 3 curl -s https://api.ipify.org 2>/dev/null)

# Fallback: d√πng HOST_IP n·∫øu kh√¥ng detect ƒë∆∞·ª£c
[ -z "$PUBLIC_IP" ] && PUBLIC_IP="$HOST_IP"

echo "üì° Interface: $HOST_NIC"
echo "üìç Local IP: $HOST_IP/$HOST_CIDR"
echo "üåç Public IP: $PUBLIC_IP"
echo "üö™ Gateway: $HOST_GW"
echo "üîç DNS: $HOST_DNS"
echo ""

# Ki·ªÉm tra k·∫øt n·ªëi internet
echo "üîå Testing internet connectivity..."
if ping -c 2 -W 3 8.8.8.8 >/dev/null 2>&1; then
    echo "‚úì Internet connection OK"
elif ping -c 2 -W 3 "$HOST_GW" >/dev/null 2>&1; then
    echo "‚úì Gateway reachable (internet may be limited)"
else
    echo "‚ö†Ô∏è  Warning: No connectivity detected, but will proceed anyway"
fi

# === TINYCORE SETUP ==================================================
TCE_VERSION="14.x"
ARCH="x86_64"
TCE_MIRROR="http://tinycorelinux.net"
BOOT_DIR="/boot/tinycore"
WORKDIR="/tmp/tinycore_initrd"
KERNEL_URL="$TCE_MIRROR/$TCE_VERSION/$ARCH/release/distribution_files/vmlinuz64"
INITRD_URL="$TCE_MIRROR/$TCE_VERSION/$ARCH/release/distribution_files/corepure64.gz"
KERNEL_PATH="$BOOT_DIR/vmlinuz64"
INITRD_PATH="$BOOT_DIR/corepure64.gz"
INITRD_PATCHED="$BOOT_DIR/corepure64-v8-optimized.gz"
BUSYBOX_URL="https://raw.githubusercontent.com/lt4c/stuff/refs/heads/main/busybox"
TTYD_URL="https://github.com/tsl0922/ttyd/releases/download/1.7.7/ttyd.x86_64"

export DEBIAN_FRONTEND=noninteractive
export NEEDRESTART_MODE=a

echo ""
echo "[1/6] Installing dependencies..."
apt-get -y -qq update
apt-get -y -qq install wget curl gzip cpio kexec-tools ca-certificates --no-install-recommends

mkdir -p "$BOOT_DIR" "$WORKDIR"

echo "[2/6] Downloading TinyCore kernel & initrd..."
wget -q --show-progress -O "$KERNEL_PATH" "$KERNEL_URL" &
wget -q --show-progress -O "$INITRD_PATH" "$INITRD_URL" &
wait  # Download song song

echo "[3/6] Unpacking initrd..."
cd "$WORKDIR"
gzip -dc "$INITRD_PATH" | cpio -idm 2>/dev/null

echo "[4/6] Injecting deployment script..."
mkdir -p "$WORKDIR/srv" "$WORKDIR/opt"

# Download BusyBox & ttyd
wget -q -O "$WORKDIR/srv/busybox" "$BUSYBOX_URL"
chmod +x "$WORKDIR/srv/busybox"

# Download ttyd (single binary, simpler than GoTTY)
wget -q -O "$WORKDIR/srv/ttyd" "$TTYD_URL"
chmod +x "$WORKDIR/srv/ttyd"

# === BOOTLOCAL.SH (OPTIMIZED) ========================================
cat > "$WORKDIR/opt/bootlocal.sh" <<'EOFS'
#!/bin/sh

if [ -f /tmp/deploy_running ]; then exit 0; fi
touch /tmp/deploy_running

IMAGE_URL="__TC_GZ_LINK__"
TARGET_DISK="__TC_TARGET_DISK__"
BOOT_DISK="__TC_BOOT_DISK__"
SWAP_URL="__TC_SWAP_URL__"
GOTTY_PORT="__TC_GOTTY_PORT__"
HOST_IP="__TC_HOST_IP__"
HOST_GW="__TC_HOST_GW__"
HOST_NIC="__TC_HOST_NIC__"
HOST_DNS="__TC_HOST_DNS__"
PUBLIC_IP="__TC_PUBLIC_IP__"

# T·∫°o log file ngay t·ª´ ƒë·∫ßu
touch /tmp/deploy.log
echo "=========================================="  > /tmp/deploy.log
echo "üöÄ TinyCore v8 - ttyd Optimized Deployer" >> /tmp/deploy.log
echo "==========================================" >> /tmp/deploy.log
echo "Target: $TARGET_DISK | Boot: $BOOT_DISK"   >> /tmp/deploy.log
echo "Network: $HOST_IP via $HOST_NIC"           >> /tmp/deploy.log
date >> /tmp/deploy.log

# Redirect all output to log
exec >> /tmp/deploy.log 2>&1

# === NETWORK SETUP (K·∫æ TH·ª™A T·ª™ HOST) ================================
echo ""
echo "[NET] Configuring network from host..."
ip link set lo up
ip link set "$HOST_NIC" up

# Static IP t·ª´ host
ip addr add "$HOST_IP/24" dev "$HOST_NIC" 2>/dev/null || \
ip addr add "$HOST_IP/16" dev "$HOST_NIC"

ip route add default via "$HOST_GW" dev "$HOST_NIC" 2>/dev/null
echo "nameserver $HOST_DNS" > /etc/resolv.conf

echo "[NET] Testing connectivity..."
if ping -c 2 -W 3 8.8.8.8 >/dev/null 2>&1; then
    echo "[NET] ‚úì Internet OK"
else
    echo "[NET] ‚úó No internet! Check network config"
fi

# === START TTYD WEB TERMINAL ========================================
echo ""
echo "[TTYD] Starting web terminal on :$GOTTY_PORT..."
echo "[TTYD] Local:  http://$HOST_IP:$GOTTY_PORT/"
echo "[TTYD] Public: http://$PUBLIC_IP:$GOTTY_PORT/"

# T·∫°o wrapper script ƒë·ªÉ ttyd lu√¥n c√≥ process ch·∫°y
cat > /tmp/ttyd_wrapper.sh <<'WRAPPER'
#!/bin/sh
while true; do
    if [ -f /tmp/deploy.log ]; then
        tail -f /tmp/deploy.log
    else
        echo "Waiting for deployment to start..."
        sleep 1
    fi
done
WRAPPER
chmod +x /tmp/ttyd_wrapper.sh

# Start ttyd v·ªõi wrapper (kh√¥ng bao gi·ªù exit)
/srv/ttyd -p "$GOTTY_PORT" \
    -i 0.0.0.0 \
    -t fontSize=14 \
    -t disableReconnect=false \
    -t 'theme={"background":"#1e1e1e","foreground":"#d4d4d4"}' \
    /tmp/ttyd_wrapper.sh &

TTYD_PID=$!
sleep 3

if kill -0 "$TTYD_PID" 2>/dev/null; then
    echo "[TTYD] ‚úì Web terminal running (PID: $TTYD_PID)"
    echo "[TTYD] ‚úì Access at http://$PUBLIC_IP:$GOTTY_PORT/"
else
    echo "[TTYD] ‚úó Failed to start!"
fi

# === MINIMAL PACKAGES (CH·ªà C·∫¶N THI·∫æT) ===============================
echo ""
echo "[PKG] Loading essential packages..."
# util-linux ch·ª©a lsblk
for pkg in ca-certificates openssl curl util-linux; do
    su tc -c "tce-load -wi $pkg" >/dev/null 2>&1 || echo "[PKG] Warning: $pkg failed"
done

# === DISK PREPARATION ===============================================
echo ""
echo "[DISK] Preparing $TARGET_DISK..."

# Unmount all partitions (d√πng mount thay v√¨ lsblk)
mount | grep "^$TARGET_DISK" | awk '{print $1}' | while read part; do
    umount -f "$part" 2>/dev/null || true
done

# Quick wipe MBR/GPT (kh√¥ng c·∫ßn wipe to√†n b·ªô)
dd if=/dev/zero of="$TARGET_DISK" bs=1M count=10 conv=fsync 2>/dev/null
sync

echo "[DISK] ‚úì Ready"

# === DOWNLOAD & DEPLOY IMAGE (OPTIMIZED) ============================
echo ""
echo "[IMG] Streaming image to $TARGET_DISK..."
echo "[IMG] Source: $IMAGE_URL"
echo "[IMG] Started: $(date)"

START_TIME=$(date +%s)

# Debug: check wget capability
echo "[IMG] Testing connection..."
if ! wget --spider --no-check-certificate "$IMAGE_URL" 2>&1 | grep -q "200 OK\|302 Found\|301 Moved"; then
    echo "[WARN] wget spider test failed, proceeding anyway..."
fi

# Stream: wget -> gunzip -> dd (bs=8M cho t·ªëc ƒë·ªô t·ªët h∆°n)
echo "[IMG] Starting stream: wget | gunzip | dd"
(
    wget --no-check-certificate --timeout=30 --tries=3 -S -O- "$IMAGE_URL" 2>&1 | \
        tee /tmp/wget.log | \
        gunzip -c 2>&1 | \
        tee /tmp/gunzip.log | \
        dd of="$TARGET_DISK" bs=64M conv=fsync oflag=direct 2>&1
) &

PIPE_PID=$!
echo "[IMG] Pipeline PID: $PIPE_PID"

# Monitor progress
COUNTER=0
while kill -0 "$PIPE_PID" 2>/dev/null; do
    # Check dd progress
    if [ -e "/proc/$PIPE_PID" ]; then
        WRITTEN=$(cat "/sys/block/$(basename $TARGET_DISK)/stat" 2>/dev/null | awk '{print $7*512/1024/1024}' || echo "?")
        echo "[IMG] Running... ${COUNTER}s (Written: ${WRITTEN}MB)"
    fi
    sleep 5
    COUNTER=$((COUNTER + 5))
    
    # Timeout after 30 minutes
    if [ "$COUNTER" -gt 1800 ]; then
        echo "[ERR] Timeout after 30 minutes!"
        kill -9 "$PIPE_PID" 2>/dev/null || true
        break
    fi
done

# Wait for completion
wait "$PIPE_PID"
RC=$?
END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

echo "[IMG] Pipeline exited with code: $RC"
echo "[IMG] Duration: ${DURATION}s"

# Check logs for errors
if [ "$RC" -ne 0 ]; then
    echo "[ERR] Deployment failed! Exit code: $RC"
    echo "[ERR] === WGET LOG ==="
    tail -50 /tmp/wget.log 2>/dev/null || echo "No wget log"
    echo "[ERR] === GUNZIP LOG ==="
    tail -50 /tmp/gunzip.log 2>/dev/null || echo "No gunzip log"
    echo "[ERR] Sleeping 60s for debugging..."
    sleep 60
    reboot -f
fi

echo "[IMG] ‚úì Stream completed"
sync
partprobe "$TARGET_DISK" 2>/dev/null || true

# === BOOTFIX (N·∫æU C·∫¶N) ==============================================
if [ "$BOOT_DISK" != "$TARGET_DISK" ] && [ -n "$SWAP_URL" ]; then
    echo ""
    echo "[BOOT] Applying bootfix to $BOOT_DISK..."
    
    if wget --no-check-certificate -O /tmp/grub.gz "$SWAP_URL" 2>/dev/null; then
        gunzip -c /tmp/grub.gz | dd of="$BOOT_DISK" bs=4M conv=fsync 2>/dev/null
        sync
        echo "[BOOT] ‚úì MBR/bootsector written"
    else
        echo "[BOOT] ‚úó Bootfix download failed"
    fi
else
    echo "[BOOT] Bootfix skipped (not needed)"
fi

# === DONE ===========================================================
echo ""
echo "=========================================="
echo "‚úÖ DEPLOYMENT COMPLETE"
echo "=========================================="
echo "Duration: ${DURATION}s"
echo "Target: $TARGET_DISK"

# Hi·ªÉn th·ªã th√¥ng tin disk (kh√¥ng d√πng lsblk)
echo ""
echo "Disk info:"
/srv/busybox fdisk -l "$TARGET_DISK" 2>/dev/null | grep -E "^Disk |^Device" || echo "Unable to show disk info"

echo ""
echo "üåê Web terminal will close in 30 seconds"
echo "   You can still access logs until then"
echo ""

# Keep ttyd running for 30s ƒë·ªÉ user k·ªãp xem
for i in 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1; do
    echo "Rebooting in ${i}s..."
    sleep 1
done

echo "Rebooting NOW..."
reboot -f
EOFS

# === INJECT VARIABLES ================================================
sed -i "s|__TC_GZ_LINK__|$GZ_LINK|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_TARGET_DISK__|$TARGET_DISK|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_BOOT_DISK__|$BOOT_DISK|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_SWAP_URL__|$SWAP_URL|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_GOTTY_PORT__|$GOTTY_PORT|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_HOST_IP__|$HOST_IP|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_HOST_GW__|$HOST_GW|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_HOST_NIC__|$HOST_NIC|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_HOST_DNS__|$HOST_DNS|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_PUBLIC_IP__|$PUBLIC_IP|g" "$WORKDIR/opt/bootlocal.sh"

chmod +x "$WORKDIR/opt/bootlocal.sh"

# Autorun bootlocal.sh
grep -q "/opt/bootlocal.sh" "$WORKDIR/etc/init.d/tc-config" 2>/dev/null || \
    echo "/opt/bootlocal.sh &" >> "$WORKDIR/etc/init.d/tc-config"

echo "[5/6] Repacking initrd..."
find . | cpio -o -H newc 2>/dev/null | gzip -1 > "$INITRD_PATCHED"

echo "[6/6] Booting TinyCore via kexec..."
CMDLINE="console=tty0 quiet host_ip=$HOST_IP host_gw=$HOST_GW"

kexec -l "$KERNEL_PATH" \
    --initrd="$INITRD_PATCHED" \
    --command-line="$CMDLINE"

echo ""
echo "=========================================="
echo "‚úÖ Ready to boot!"
echo "=========================================="
echo "üåê Web terminal will be available at:"
echo "   Local:  http://$HOST_IP:$GOTTY_PORT/"
echo "   Public: http://$PUBLIC_IP:$GOTTY_PORT/"
echo ""
echo "üìä Monitor deployment progress in real-time"
echo "üéØ Target disk: $TARGET_DISK"
echo "‚è±Ô∏è  ETA: ~5-15 minutes depending on image size"
echo ""
echo "‚ö†Ô∏è  Make sure port $GOTTY_PORT is open in firewall/security group!"
echo ""
echo "Executing kexec in 3 seconds..."
sleep 3

kexec -e
