#!/bin/bash
set -euo pipefail
# =====================================================================
# TinyCore Auto Windows Deployer v19-Ultimate
# - Network: Auto-detect from DPCT host (passthrough/bridge)
# - Deploy: Stream wget|gunzip|dd với progress monitoring
# - Auto-Expand: NTFS resize với force mode (-f -f)
# - Safety: Smart disk detection, unmount, bootfix
# =====================================================================

# === USER CONFIG =====================================================
GZ_LINK="https://148.100.76.25:3923/WindowsCustom.gz"
DISCORD_WEBHOOK="https://discord.com/api/webhooks/1460967132761423913/8cPQaQCrlvc-0CWC7VpM30bKr1ulMPUrCFZAUr7r06VPqFkbgCvCRbuyde_Ffc-0joff"
SWAP_URL="https://raw.githubusercontent.com/lt4c/stuff/refs/heads/main/grubsdbuefiwin.gz"

# === NETWORK AUTO-DETECT (từ host) ===================================
echo "[NETWORK] Detecting host network configuration..."
MAIN_IF=$(ip route get 8.8.8.8 2>/dev/null | grep -oP 'dev \K\S+' | head -n1 || echo "")
if [ -n "$MAIN_IF" ]; then
    MY_IP=$(ip -4 addr show "$MAIN_IF" | grep -oP '(?<=inet\s)\d+(\.\d+){3}/\d+' | head -n1 || echo "")
    MY_GW=$(ip route | grep default | grep "$MAIN_IF" | awk '{print $3}' | head -n1 || echo "")
    MY_DNS="8.8.8.8"
    
    if [ -n "$MY_IP" ]; then
        CMD_IP="STATIC_IP=${MY_IP} STATIC_GW=${MY_GW} STATIC_DNS=${MY_DNS}"
        echo "[NETWORK] Detected: $MAIN_IF ($MY_IP) -> Will pass to TinyCore"
    else
        CMD_IP=""
        echo "[NETWORK] Interface found but no IP - TinyCore will use DHCP"
    fi
else
    CMD_IP=""
    echo "[NETWORK] No active interface - TinyCore will auto-detect"
fi

# === TINYCORE CONFIGURATION ==========================================
TCE_VERSION="14.x"
ARCH="x86_64"
TCE_MIRROR="http://tinycorelinux.net"
BOOT_DIR="/boot/tinycore"
WORKDIR="/tmp/tinycore_initrd"
KERNEL_URL="$TCE_MIRROR/$TCE_VERSION/$ARCH/release/distribution_files/vmlinuz64"
INITRD_URL="$TCE_MIRROR/$TCE_VERSION/$ARCH/release/distribution_files/corepure64.gz"
KERNEL_PATH="$BOOT_DIR/vmlinuz64"
INITRD_PATH="$BOOT_DIR/corepure64.gz"
INITRD_PATCHED="$BOOT_DIR/corepure64-v19-ultimate.gz"
BUSYBOX_URL="https://raw.githubusercontent.com/lt4c/stuff/refs/heads/main/busybox"

# === ENVIRONMENT SETUP ===============================================
export DEBIAN_FRONTEND=noninteractive
export NEEDRESTART_MODE=a
echo 'kexec-tools kexec-tools/load_kexec boolean true' | debconf-set-selections

log_msg() { echo "[$(date +'%H:%M:%S')] $1"; }

log_msg "=== Phase 1/6: Installing dependencies ==="
apt-get -y -qq update
apt-get -y -qq install wget curl gzip cpio kexec-tools parted gdisk \
    ca-certificates util-linux iproute2 --no-install-recommends

mkdir -p "$BOOT_DIR" "$WORKDIR"

log_msg "=== Phase 2/6: Fetching TinyCore artifacts ==="
wget -q -O "$KERNEL_PATH" "$KERNEL_URL"
wget -q -O "$INITRD_PATH" "$INITRD_URL"
log_msg "Kernel: $(du -h "$KERNEL_PATH" | cut -f1)"
log_msg "Initrd: $(du -h "$INITRD_PATH" | cut -f1)"

log_msg "=== Phase 3/6: Unpacking initrd ==="
cd "$WORKDIR"
gzip -dc "$INITRD_PATH" | cpio -idm 2>/dev/null
log_msg "Initrd unpacked successfully"

log_msg "=== Phase 4/6: Injecting deployment script ==="
mkdir -p "$WORKDIR/srv" "$WORKDIR/opt"
wget -q -O "$WORKDIR/srv/busybox" "$BUSYBOX_URL"
chmod +x "$WORKDIR/srv/busybox"

cat > "$WORKDIR/opt/bootlocal.sh" <<'BOOTLOCAL_SCRIPT'
#!/bin/sh
# =============================================================================
# TinyCore Windows Deployment Script v19-Ultimate
# =============================================================================
IMAGE_URL="__TC_GZ_LINK__"
DISCORD_WEBHOOK="__TC_DISCORD__"
SWAP_URL="__TC_SWAP_URL__"
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# Parse network config from kernel cmdline
for x in $(cat /proc/cmdline); do
  case "$x" in
    STATIC_IP=*) MANUAL_IP="${x#*=}" ;;
    STATIC_GW=*) MANUAL_GW="${x#*=}" ;;
    STATIC_DNS=*) MANUAL_DNS="${x#*=}" ;;
  esac
done

# === UTILITIES =======================================================
safe_echo() { echo "$1" | sed 's/"/\\"/g; s/\\/\\\\/g'; }

post_discord() {
  [ -z "$DISCORD_WEBHOOK" ] && return 0
  echo "$1" | awk -v max=1900 '{
    line=$0
    while(length(line)>max){
      print substr(line,1,max)
      line=substr(line,max+1)
    }
    if(length(line)>0) print line
  }' | while read -r chunk; do
    [ -z "$chunk" ] && continue
    curl -m 8 -sS -H "Content-Type: application/json" \
      -d "{\"content\":\"\`\`\`$(safe_echo "$chunk")\`\`\`\"}" \
      "$DISCORD_WEBHOOK" >/dev/null 2>&1 || true
    sleep 0.3
  done
}

log() {
  local msg="[$(date +'%H:%M:%S')] $1"
  echo "$msg" | tee -a /srv/lab
  post_discord "$msg"
}

# === HTTP SERVER =====================================================
mkdir -p /srv; touch /srv/lab
chmod +x /srv/busybox 2>/dev/null || true
/srv/busybox httpd -p 80 -h /srv 2>/dev/null && log "✓ HTTP server :80" || log "⚠ HTTP failed"

( while true; do echo "[HEARTBEAT] $(date)" >> /srv/lab; sleep 10; done ) &

log "=========================================="
log "TinyCore Deployer v19-Ultimate"
log "=========================================="
log "System: $(uname -sr)"
log "Memory: $(free -m | awk 'NR==2{printf "%sMB/%sMB", $3,$2}')"

# === PACKAGE INSTALLATION ============================================
install_pkg() {
  for attempt in 1 2 3; do
    if su tc -c "tce-load -wi $1" >> /srv/lab 2>&1; then
      log "✓ $1 loaded"
      return 0
    fi
    sleep 2
  done
  log "⚠ $1 load failed (continuing)"
  return 1
}

log "Loading packages..."
install_pkg "ca-certificates.tcz"
install_pkg "openssl.tcz"
install_pkg "curl.tcz"
install_pkg "openssh.tcz"
install_pkg "parted.tcz"
install_pkg "gdisk.tcz"
install_pkg "ntfs-3g.tcz"

/usr/local/etc/init.d/openssh start >/dev/null 2>&1 && log "✓ SSH started" || true

# === NETWORK SETUP ===================================================
log "Configuring network..."
ifconfig lo up

# Try manual config first (from host)
NETWORK_UP=0
if [ -n "$MANUAL_IP" ]; then
  log "Using static config from host: $MANUAL_IP"
  ip link set eth0 up
  ip addr flush dev eth0
  ip addr add "$MANUAL_IP" dev eth0
  [ -n "$MANUAL_GW" ] && ip route add default via "$MANUAL_GW"
  echo "nameserver ${MANUAL_DNS:-8.8.8.8}" > /etc/resolv.conf
  
  if ip -4 addr show dev eth0 | grep -q 'inet '; then
    NETWORK_UP=1
    log "✓ Static IP configured"
    ip -4 addr show dev eth0 | sed 's/^/  /' >> /srv/lab
  fi
fi

# Fallback to DHCP
if [ "$NETWORK_UP" -eq 0 ]; then
  log "Trying DHCP on eth0..."
  ip link set eth0 up
  udhcpc -b -i eth0 -t 8 -T 2 -A 3 >> /srv/lab 2>&1 || true
  
  for i in 1 2 3 4 5 6 7 8 9 10; do
    if ip -4 addr show dev eth0 | grep -q 'inet '; then
      NETWORK_UP=1
      log "✓ DHCP acquired on eth0"
      ip -4 addr show dev eth0 | sed 's/^/  /' >> /srv/lab
      break
    fi
    sleep 1
  done
fi

if [ "$NETWORK_UP" -eq 0 ]; then
  log "⚠ WARNING: No network configured"
  log "Deployment may fail without network!"
fi

# Test connectivity
if ping -c 2 -W 3 8.8.8.8 >/dev/null 2>&1; then
  log "✓ Internet connectivity OK"
else
  log "⚠ No internet connectivity"
fi

# === DISK DETECTION ==================================================
log "Detecting target disk..."

TARGET=""
# Prefer non-boot disks first
for disk in /dev/sdb /dev/vdb /dev/nvme1n1 /dev/sda /dev/vda /dev/nvme0n1; do
  if [ -b "$disk" ]; then
    TARGET="$disk"
    break
  fi
done

# Fallback
if [ -z "$TARGET" ]; then
  TARGET=$(lsblk -dno NAME,TYPE 2>/dev/null | awk '$2=="disk"{print "/dev/"$1; exit}')
fi

if [ -z "$TARGET" ] || [ ! -b "$TARGET" ]; then
  log "✗ ERROR: No disk found. Rebooting..."
  sleep 5
  reboot -f
fi

log "Target disk: $TARGET"
lsblk "$TARGET" -o NAME,SIZE,TYPE,FSTYPE 2>/dev/null | sed 's/^/  /' >> /srv/lab

DISK_SIZE_GB=$(lsblk -bno SIZE "$TARGET" 2>/dev/null | awk '{printf "%.1f", $1/1024/1024/1024}')
log "Disk size: ${DISK_SIZE_GB}GB"

# === UNMOUNT & PREPARE ===============================================
log "Preparing disk..."

# Unmount all partitions
for mnt in $(mount | awk -v t="$TARGET" '$1 ~ t {print $3}'); do
  umount -f "$mnt" 2>/dev/null && log "✓ Unmounted: $mnt" || true
done

# Disable swap
swapoff -a 2>/dev/null || true

# Wipe first 10MB (partition table)
dd if=/dev/zero of="$TARGET" bs=1M count=10 conv=fsync 2>/dev/null || true
sync
sleep 2

# Detect boot disk
BOOT_DEVICE=$(readlink -f /dev/root 2>/dev/null || echo '')
if [ -n "$BOOT_DEVICE" ]; then
  BOOTDISK=$(lsblk -no PKNAME "$BOOT_DEVICE" 2>/dev/null | sed 's#^#/dev/#')
else
  BOOTDISK="/dev/sda"
fi
[ -z "$BOOTDISK" ] && BOOTDISK="/dev/sda"
log "Boot disk: $BOOTDISK"

# === IMAGE DEPLOYMENT ================================================
log "=========================================="
log "Starting image deployment"
log "=========================================="
log "Source: $IMAGE_URL"
log "Target: $TARGET"

START_TIME=$(date +%s)

# Stream deployment
log "Pipeline: curl -> gunzip -> dd"

(
  curl -L -k -f --progress-bar "$IMAGE_URL" 2>&1 \
  | tee >(grep -o '[0-9]*\.[0-9]*%' >> /srv/curl_progress) \
  | gunzip -c \
  | dd of="$TARGET" bs=64M conv=fsync oflag=direct 2>&1 \
  | tee -a /srv/lab
) &

PIPE_PID=$!
log "Deployment started (PID: $PIPE_PID)"

# Monitor progress
LAST_OFFSET=0
CHECK_INTERVAL=5

while kill -0 "$PIPE_PID" 2>/dev/null; do
  ELAPSED=$(($(date +%s) - START_TIME))
  
  DD_PID=$(pidof dd 2>/dev/null | awk '{print $1}')
  
  if [ -n "$DD_PID" ] && [ -r "/proc/$DD_PID/fdinfo/1" ]; then
    OFFSET=$(awk '/pos:/{print $2}' "/proc/$DD_PID/fdinfo/1" 2>/dev/null | head -n1)
    [ -z "$OFFSET" ] && OFFSET=0
    
    OFFSET_MB=$((OFFSET / 1024 / 1024))
    
    if [ "$OFFSET" -gt "$LAST_OFFSET" ]; then
      DIFF=$((OFFSET - LAST_OFFSET))
      SPEED_MBS=$((DIFF / CHECK_INTERVAL / 1024 / 1024))
    else
      SPEED_MBS=0
    fi
    
    log "Progress: ${OFFSET_MB}MB | Speed: ${SPEED_MBS}MB/s | Time: ${ELAPSED}s"
    LAST_OFFSET=$OFFSET
  else
    log "Deploying... (${ELAPSED}s)"
  fi
  
  sleep $CHECK_INTERVAL
done

wait "$PIPE_PID"
RC=$?
TOTAL_TIME=$(($(date +%s) - START_TIME))

if [ "$RC" -ne 0 ]; then
  log "✗ ERROR: Deployment failed (exit code: $RC)"
  log "Total time: ${TOTAL_TIME}s"
  tail -50 /srv/lab >> /srv/lab
  sleep 5
  reboot -f
fi

sync
sleep 2

log "✓ Deployment successful in ${TOTAL_TIME}s"

# === AUTO-EXPAND NTFS ================================================
log "=========================================="
log "Auto-Expand: Fixing GPT & Resizing NTFS"
log "=========================================="

# Fix GPT (expand to full disk)
log "Fixing GPT table..."
sgdisk -e "$TARGET" >> /srv/lab 2>&1 || true
partprobe "$TARGET" 2>/dev/null || true
sleep 3

# Get last partition number
LAST_PART=$(parted -m "$TARGET" print 2>/dev/null | tail -n 1 | awk -F: '{print $1}')
log "Last partition: #$LAST_PART"

# Delete recovery partition if exists (usually partition 3 or 4)
if [ -n "$LAST_PART" ] && [ "$LAST_PART" -ge 3 ]; then
  PART_TYPE=$(parted -m "$TARGET" print 2>/dev/null | grep "^${LAST_PART}:" | awk -F: '{print $5}')
  log "Partition #$LAST_PART type: $PART_TYPE"
  
  # Check if it's recovery partition (usually < 1GB or labeled recovery)
  PART_SIZE=$(parted -m "$TARGET" print 2>/dev/null | grep "^${LAST_PART}:" | awk -F: '{print $4}')
  if echo "$PART_TYPE" | grep -qi "recovery\|diag" || echo "$PART_SIZE" | grep -qE "^[0-9]{1,3}MB$"; then
    log "Deleting recovery partition #$LAST_PART ($PART_SIZE)..."
    parted -s "$TARGET" rm "$LAST_PART" >> /srv/lab 2>&1
    LAST_PART=$((LAST_PART - 1))
    log "New last partition: #$LAST_PART"
  fi
fi

# Resize main Windows partition (usually partition 2)
if [ -n "$LAST_PART" ] && [ "$LAST_PART" -gt 0 ]; then
  log "Expanding partition #$LAST_PART to 100%..."
  parted -s "$TARGET" resizepart "$LAST_PART" 100% >> /srv/lab 2>&1 || true
  
  partprobe "$TARGET" 2>/dev/null || true
  sleep 2
  
  # Determine partition device
  PART_DEV="${TARGET}${LAST_PART}"
  echo "$TARGET" | grep -q "nvme" && PART_DEV="${TARGET}p${LAST_PART}"
  
  if [ -b "$PART_DEV" ]; then
    log "NTFS resize on $PART_DEV..."
    
    # Phase 1: Clear dirty flags and bad sectors
    log "Phase 1: ntfsfix (clear dirty & bad sectors)"
    ntfsfix -b -d "$PART_DEV" >> /srv/lab 2>&1 || true
    
    # Phase 2: Force resize (double -f for maximum force)
    log "Phase 2: ntfsresize (force mode -f -f)"
    if ntfsresize -f -f -v "$PART_DEV" >> /srv/lab 2>&1; then
      log "✓ SUCCESS: NTFS filesystem expanded!"
      log "Windows will boot with full disk space available."
    else
      log "⚠ WARNING: ntfsresize failed"
      log "You may need to extend filesystem in Windows Disk Management"
      log "Steps: Right-click C: drive -> Extend Volume"
    fi
  else
    log "⚠ Partition device $PART_DEV not found"
  fi
else
  log "⚠ Could not detect partition to resize"
fi

log "Final disk layout:"
lsblk "$TARGET" -o NAME,SIZE,TYPE,FSTYPE 2>/dev/null | sed 's/^/  /' >> /srv/lab

# === BOOTFIX =========================================================
if [ "$BOOTDISK" != "$TARGET" ] && [ -b "$BOOTDISK" ]; then
  log "Applying boot sector fix to $BOOTDISK..."
  
  if curl -L -k -o /tmp/grub.gz "$SWAP_URL" 2>> /srv/lab; then
    if [ -s /tmp/grub.gz ]; then
      if gunzip -c /tmp/grub.gz | dd of="$BOOTDISK" bs=4M 2>> /srv/lab; then
        sync
        log "✓ Boot sector updated"
      else
        log "⚠ Boot sector write failed"
      fi
    fi
  else
    log "⚠ Failed to download boot sector"
  fi
else
  log "Boot sector fix skipped (boot == target)"
fi

# === COMPLETION ======================================================
log "=========================================="
log "✓ All operations completed successfully!"
log "Total deployment time: ${TOTAL_TIME}s"
log "=========================================="
log "Rebooting into Windows..."
sleep 5
reboot -f
BOOTLOCAL_SCRIPT

# === VARIABLE INJECTION ==============================================
log_msg "Injecting configuration..."
sed -i "s#__TC_GZ_LINK__#${GZ_LINK}#g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s#__TC_DISCORD__#${DISCORD_WEBHOOK}#g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s#__TC_SWAP_URL__#${SWAP_URL}#g" "$WORKDIR/opt/bootlocal.sh"
chmod +x "$WORKDIR/opt/bootlocal.sh"

if ! grep -q "/opt/bootlocal.sh" "$WORKDIR/etc/init.d/tc-config" 2>/dev/null; then
    echo "/opt/bootlocal.sh &" >> "$WORKDIR/etc/init.d/tc-config"
fi

# === INITRD REPACKING ================================================
log_msg "=== Phase 5/6: Repacking initrd ==="
cd "$WORKDIR"
if find . | cpio -o -H newc 2>/dev/null | gzip -9 > "$INITRD_PATCHED"; then
    log_msg "Initrd repacked: $(du -h "$INITRD_PATCHED" | cut -f1)"
else
    log_msg "ERROR: Failed to repack initrd"
    exit 1
fi

# === KEXEC BOOT ======================================================
log_msg "=== Phase 6/6: Preparing kexec boot ==="

CMDLINE="console=ttyS0 console=tty0 quiet loglevel=3 net.ifnames=0 biosdevname=0 $CMD_IP"
log_msg "Cmdline: $CMDLINE"

if kexec -l "$KERNEL_PATH" --initrd="$INITRD_PATCHED" --command-line="$CMDLINE"; then
    log_msg "Kernel loaded successfully"
else
    log_msg "ERROR: Failed to load kernel"
    exit 1
fi

# === FINAL SUMMARY ===================================================
echo ""
echo "===================================================================="
echo "  TinyCore Auto Deployer v19-Ultimate"
echo "===================================================================="
echo "  ✓ Network: Auto-detect from DPCT host (passthrough)"
echo "  ✓ Deploy: Stream wget|gunzip|dd with progress monitoring"
echo "  ✓ Auto-Expand: GPT fix + NTFS resize with force mode"
echo "  ✓ Safety: Smart disk detection, unmount, bootfix"
echo "  ✓ Monitoring: Discord notifications + HTTP server"
echo "===================================================================="
echo "  Booting TinyCore in 3 seconds..."
echo "===================================================================="
echo ""

sleep 3
log_msg "Executing kexec..."
kexec -e
