#!/bin/bash
set -euo pipefail
# =====================================================================
# TinyCore Auto Windows Deployer
# =====================================================================

# === USER CONFIG =====================================================
GZ_LINK="https://148.100.76.25:3923/WindowsCustom.gz"
DISCORD_WEBHOOK="https://discord.com/api/webhooks/1460967132761423913/8cPQaQCrlvc-0CWC7VpM30bKr1ulMPUrCFZAUr7r06VPqFkbgCvCRbuyde_Ffc-0joff"
SWAP_URL="https://raw.githubusercontent.com/lt4c/stuff/refs/heads/main/grubsdbuefiwin.gz"
BUSYBOX_URL="https://raw.githubusercontent.com/lt4c/stuff/refs/heads/main/busybox"

# === 1. NETWORK DETECTION (HOST) =====================================
echo "[HOST] Detecting Network..."
MAIN_IF=$(ip route get 8.8.8.8 | grep -oP 'dev \K\S+' | head -n1)
[ -z "$MAIN_IF" ] && MAIN_IF=$(ip -4 route show default | awk '{print $5}' | head -n1)

MY_IP=$(ip -4 addr show "$MAIN_IF" | grep -oP '(?<=inet\s)\d+(\.\d+){3}/\d+' | head -n1)
MY_GW=$(ip route | grep default | grep "$MAIN_IF" | awk '{print $3}' | head -n1)
MY_DNS="8.8.8.8"

if [ -z "$MAIN_IF" ] || [ -z "$MY_IP" ] || [ -z "$MY_GW" ]; then
  echo "[FATAL] Network detection failed. Exiting."
  exit 1
fi

echo "[HOST] NIC: $MAIN_IF | IP: $MY_IP | GW: $MY_GW"
CMD_IP="STATIC_IP=${MY_IP} STATIC_GW=${MY_GW} STATIC_DNS=${MY_DNS}"

# === 2. PREPARE TINYCORE ARTIFACTS ===================================
TCE_MIRROR="http://tinycorelinux.net/14.x/x86_64/release/distribution_files"
BOOT_DIR="/boot/tinycore"
WORKDIR="/tmp/tinycore_initrd"

echo "[SETUP] Installing dependencies..."
export DEBIAN_FRONTEND=noninteractive
apt-get -y -qq update >/dev/null
apt-get -y -qq install wget curl gzip cpio kexec-tools parted gdisk ca-certificates --no-install-recommends >/dev/null

mkdir -p "$BOOT_DIR" "$WORKDIR"

echo "[SETUP] Downloading TinyCore (Parallel)..."
(wget -q -O "$BOOT_DIR/vmlinuz64" "$TCE_MIRROR/vmlinuz64") &
(wget -q -O "$BOOT_DIR/corepure64.gz" "$TCE_MIRROR/corepure64.gz") &
wait

if [ ! -s "$BOOT_DIR/vmlinuz64" ] || [ ! -s "$BOOT_DIR/corepure64.gz" ]; then
    echo "[FATAL] Download failed."
    exit 1
fi

echo "[SETUP] Unpacking initrd..."
cd "$WORKDIR"
gzip -dc "$BOOT_DIR/corepure64.gz" | cpio -idm --quiet

echo "[SETUP] Injecting scripts..."
mkdir -p "$WORKDIR/srv" "$WORKDIR/opt"
wget -q -O "$WORKDIR/srv/busybox" "$BUSYBOX_URL"
chmod +x "$WORKDIR/srv/busybox"

# === 3. INJECT BOOTLOCAL.SH (CORE LOGIC) =============================
cat > "$WORKDIR/opt/bootlocal.sh" <<'EOS'
#!/bin/sh
# TinyCore Internal Script v8
IMAGE_URL="__TC_GZ_LINK__"
DISCORD_WEBHOOK="__TC_DISCORD__"
SWAP_URL="__TC_SWAP_URL__"

# --- HELPER FUNCTIONS ---
safe_echo() { echo "$1" | sed 's/"/\\"/g'; }
post_discord() {
  [ -z "$DISCORD_WEBHOOK" ] && return 0
  echo "$1" | awk '{print substr($0,1,1800)}' | while read -r c; do
    [ -z "$c" ] && continue
    curl -m 3 -sS -H "Content-Type: application/json" \
      -d "{\"content\":\"\`\`\`$(safe_echo "$c")\`\`\`\"}" "$DISCORD_WEBHOOK" >/dev/null 2>&1 || true
  done
}
log(){ echo "$1" | tee -a /srv/lab >/dev/null; post_discord "$1"; }

# --- INIT ---
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
mkdir -p /srv && touch /srv/lab
/srv/busybox httpd -p 80 -h /srv &

# Parse Host Network Params
for x in $(cat /proc/cmdline); do
  case "$x" in
    STATIC_IP=*) MIP="${x#*=}" ;;
    STATIC_GW=*) MGW="${x#*=}" ;;
    STATIC_DNS=*) MDNS="${x#*=}" ;;
  esac
done

# --- NETWORK SETUP ---
log "[BOOT] TinyCore v8-Turbo started."
ip link set lo up
ip link set eth0 up

if [ -n "$MIP" ]; then
  log "[NET] Static: $MIP"
  ip addr add "$MIP" dev eth0
  ip route add default via "$MGW"
  echo "nameserver $MDNS" > /etc/resolv.conf
else
  log "[NET] DHCP Request..."
  udhcpc -b -i eth0 -t 5 -T 3 >/dev/null 2>&1
fi

# Wait for network
for i in $(seq 1 10); do
  ping -c 1 -W 1 8.8.8.8 >/dev/null 2>&1 && break
  sleep 1
done

# --- LOAD PACKAGES ---
log "[PKG] Loading tools..."
tce-load -wi ca-certificates openssl curl openssh parted gdisk ntfs-3g >/dev/null 2>&1
/usr/local/etc/init.d/openssh start >/dev/null 2>&1 &

# --- DISK SELECTION ---
# Priority: NVMe -> VDA -> SDA
TARGET=""
for d in /dev/nvme0n1 /dev/vda /dev/sda; do
  if [ -b "$d" ]; then TARGET="$d"; break; fi
done

[ -z "$TARGET" ] && { log "[FATAL] No disk found! Rebooting..."; sleep 5; reboot -f; }
log "[DISK] Target: $TARGET"

# Wipe & Unmount
umount -f "${TARGET}"* 2>/dev/null
swapoff -a
dd if=/dev/zero of="$TARGET" bs=1M count=10 status=none
sync

# --- DOWNLOAD & WRITE (TURBO MODE) ---
log "[IMG] Stream: $IMAGE_URL -> $TARGET (bs=64M)"
(
  wget --no-check-certificate -qO- "$IMAGE_URL" \
  | gunzip -c \
  | dd of="$TARGET" bs=64M conv=fsync status=none
) &
PIPE_PID=$!

# Monitor loop
start_ts=$(date +%s)
while kill -0 "$PIPE_PID" 2>/dev/null; do
  sleep 10
  curr_ts=$(date +%s)
  echo "[IMG] Running... $((curr_ts - start_ts))s" >> /srv/lab
done

wait "$PIPE_PID"
if [ "$?" -ne 0 ]; then
  log "[FATAL] Pipeline failed. Rebooting..."
  reboot -f
fi

# ==================================================================
# SMART EXPAND LOGIC (MERGED)
# ==================================================================
log "[EXPAND] Image written. Optimizing partitions..."
partprobe "$TARGET" || true
sleep 1

# 1. Fix GPT Header (Ä‘Ã¡ backup header xuá»‘ng cuá»‘i Ä‘Ä©a)
sgdisk -e "$TARGET" >/dev/null 2>&1 || true
partprobe "$TARGET"
sleep 1

# 2. XÃ³a phÃ¢n vÃ¹ng Recovery/OEM cháº·n Ä‘Æ°á»ng (Láº·p 2 láº§n Ä‘á»ƒ cháº¯c cháº¯n)
for loop in 1 2; do
    LAST_INFO=$(parted -m "$TARGET" unit MB print 2>/dev/null | tail -n 1 | grep -v "BYT")
    LAST_NUM=$(echo "$LAST_INFO" | cut -d: -f1)
    LAST_SIZE=$(echo "$LAST_INFO" | cut -d: -f4 | tr -d 'MB' | cut -d. -f1) # Láº¥y pháº§n nguyÃªn

    # Náº¿u < 2048MB (2GB) thÃ¬ xÃ³a. Náº¿u lá»›n hÆ¡n thÃ¬ thÃ´i (Ä‘Ã³ lÃ  á»• C)
    if [ -n "$LAST_NUM" ] && [ "$LAST_SIZE" -lt 2048 ]; then
        log "[EXPAND] Removing blocker partition #$LAST_NUM (${LAST_SIZE}MB)"
        parted -s "$TARGET" rm "$LAST_NUM" >/dev/null 2>&1
        partprobe "$TARGET"
        sleep 1
    else
        break
    fi
done

# 3. Resize á»• C (PhÃ¢n vÃ¹ng cuá»‘i cÃ¹ng cÃ²n láº¡i)
TARGET_PART=$(parted -m "$TARGET" print 2>/dev/null | tail -n 1 | cut -d: -f1)

if [ -n "$TARGET_PART" ]; then
    log "[EXPAND] Expanding Partition #$TARGET_PART to 100%..."
    parted -s "$TARGET" resizepart "$TARGET_PART" 100% >/dev/null 2>&1
    partprobe "$TARGET"
    sleep 1
    
    # XÃ¡c Ä‘á»‹nh tÃªn device (NVMe dÃ¹ng p1, SATA dÃ¹ng 1)
    case "$TARGET" in
        *[0-9]) PART_DEV="${TARGET}p${TARGET_PART}" ;;
        *)      PART_DEV="${TARGET}${TARGET_PART}"   ;;
    esac

    # 4. Expand NTFS Filesystem
    if [ -b "$PART_DEV" ]; then
        log "[NTFS] Fixing & Resizing filesystem..."
        ntfsfix -b -d "$PART_DEV" >/dev/null 2>&1 || true  # Clear dirty bit
        if ntfsresize -f -b "$PART_DEV" >/dev/null 2>&1; then
             log "[SUCCESS] NTFS Expanded."
        else
             log "[WARN] ntfsresize issue (Windows will fix chkdsk)."
        fi
    fi
fi

# ==================================================================
# SECONDARY DISK LOGIC
# ==================================================================
# TÃ¬m táº¥t cáº£ á»• Ä‘Ä©a, trá»« á»• TARGET vÃ  á»• USB Boot (Size < 4GB)
for DISK in $(lsblk -dno NAME,TYPE | awk '$2=="disk"{print "/dev/"$1}'); do
    [ "$DISK" == "$TARGET" ] && continue
    
    # Bá» qua USB boot (check size < 4GB)
    DISK_SIZE=$(lsblk -bno SIZE "$DISK" | head -n1)
    [ "$DISK_SIZE" -lt 4000000000 ] && continue

    log "[DATA] Found extra disk: $DISK. Formatting D:..."
    parted -s "$DISK" mklabel gpt mkpart "Data" ntfs 0% 100% >/dev/null 2>&1
    partprobe "$DISK"
    sleep 1
    
    case "$DISK" in
        *[0-9]) DATA_PART="${DISK}p1" ;;
        *)      DATA_PART="${DISK}1"   ;;
    esac
    
    if [ -b "$DATA_PART" ]; then
        mkfs.ntfs -Q -f -L "DataDisk" "$DATA_PART" >/dev/null 2>&1
        log "[DATA] Formatted $DATA_PART"
    fi
done

# ==================================================================
# BOOT FIX & REBOOT
# ==================================================================
BOOT_DISK=$(lsblk -no PKNAME $(findmnt -n -o SOURCE /) 2>/dev/null)
if [ -n "$BOOT_DISK" ] && [ "/dev/$BOOT_DISK" != "$TARGET" ]; then
    log "[BOOTFIX] Flashing MBR to Host Boot Disk..."
    wget --no-check-certificate -qO- "$SWAP_URL" | gunzip -c | dd of="/dev/$BOOT_DISK" bs=4M count=100 status=none || true
fi

log "[DONE] Deployment Success. Rebooting..."
sleep 2
reboot -f
EOS

# === 4. FINALIZE & KEXEC =============================================
# Inject Variables
sed -i "s|__TC_GZ_LINK__|${GZ_LINK}|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_DISCORD__|${DISCORD_WEBHOOK}|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_SWAP_URL__|${SWAP_URL}|g" "$WORKDIR/opt/bootlocal.sh"
chmod +x "$WORKDIR/opt/bootlocal.sh"

# Auto-start
echo "/opt/bootlocal.sh &" >> "$WORKDIR/etc/init.d/tc-config"

echo "[SETUP] Repacking initrd (Fast Mode)..."
# DÃ¹ng gzip -1 Ä‘á»ƒ nÃ©n nhanh hÆ¡n
find . | cpio -o -H newc --quiet | gzip -1 > "$BOOT_DIR/corepure64-custom.gz"

echo "[EXEC] Kexec TinyCore..."
CMDLINE="console=ttyS0 quiet loglevel=3 net.ifnames=0 biosdevname=0 $CMD_IP"

kexec -l "$BOOT_DIR/vmlinuz64" \
      --initrd="$BOOT_DIR/corepure64-custom.gz" \
      --command-line="$CMDLINE"

echo "===================================================="
echo "ðŸš€ TinyCore 8."
echo "ok bye"
echo "===================================================="
kexec -e
