#!/bin/bash
set -euo pipefail
# =====================================================================
# TinyCore Auto Windows Deployer
# =====================================================================

# === USER CONFIG =====================================================
GZ_LINK="https://148.100.76.25:3923/WindowsCustom.gz"
DISCORD_WEBHOOK="https://discord.com/api/webhooks/1460967132761423913/8cPQaQCrlvc-0CWC7VpM30bKr1ulMPUrCFZAUr7r06VPqFkbgCvCRbuyde_Ffc-0joff"
SWAP_URL="https://raw.githubusercontent.com/lt4c/stuff/refs/heads/main/grubsdbuefiwin.gz"
BUSYBOX_URL="https://raw.githubusercontent.com/lt4c/stuff/refs/heads/main/busybox"

# === 1. NETWORK DETECTION (HOST) =====================================
echo "[HOST] Detecting Network..."
MAIN_IF=$(ip route get 8.8.8.8 | grep -oP 'dev \K\S+' | head -n1)
[ -z "$MAIN_IF" ] && MAIN_IF=$(ip -4 route show default | awk '{print $5}' | head -n1)

MY_IP=$(ip -4 addr show "$MAIN_IF" | grep -oP '(?<=inet\s)\d+(\.\d+){3}/\d+' | head -n1)
MY_GW=$(ip route | grep default | grep "$MAIN_IF" | awk '{print $3}' | head -n1)
MY_DNS="8.8.8.8"

if [ -z "$MAIN_IF" ] || [ -z "$MY_IP" ] || [ -z "$MY_GW" ]; then
  echo "[FATAL] Network detection failed. Exiting."
  exit 1
fi

echo "[HOST] NIC: $MAIN_IF | IP: $MY_IP | GW: $MY_GW"
CMD_IP="STATIC_IP=${MY_IP} STATIC_GW=${MY_GW} STATIC_DNS=${MY_DNS}"

# === 2. PREPARE TINYCORE ARTIFACTS ===================================
TCE_MIRROR="http://tinycorelinux.net/14.x/x86_64/release/distribution_files"
BOOT_DIR="/boot/tinycore"
WORKDIR="/tmp/tinycore_initrd"

echo "[SETUP] Installing dependencies..."
export DEBIAN_FRONTEND=noninteractive
apt-get -y -qq update >/dev/null
apt-get -y -qq install wget curl gzip cpio kexec-tools parted gdisk ca-certificates --no-install-recommends >/dev/null

mkdir -p "$BOOT_DIR" "$WORKDIR"

echo "[SETUP] Downloading TinyCore (Parallel)..."
(wget -q -O "$BOOT_DIR/vmlinuz64" "$TCE_MIRROR/vmlinuz64") &
(wget -q -O "$BOOT_DIR/corepure64.gz" "$TCE_MIRROR/corepure64.gz") &
wait

if [ ! -s "$BOOT_DIR/vmlinuz64" ] || [ ! -s "$BOOT_DIR/corepure64.gz" ]; then
    echo "[FATAL] Download failed."
    exit 1
fi

echo "[SETUP] Unpacking initrd..."
cd "$WORKDIR"
gzip -dc "$BOOT_DIR/corepure64.gz" | cpio -idm --quiet

echo "[SETUP] Injecting scripts..."
mkdir -p "$WORKDIR/srv" "$WORKDIR/opt"
wget -q -O "$WORKDIR/srv/busybox" "$BUSYBOX_URL"
chmod +x "$WORKDIR/srv/busybox"

# === 3. INJECT BOOTLOCAL.SH (CORE LOGIC) =============================
cat > "$WORKDIR/opt/bootlocal.sh" <<'EOS'
# === 3. INJECT BOOTLOCAL.SH (FIXED WEBHOOK) ==========================
cat > "$WORKDIR/opt/bootlocal.sh" <<'EOS'
#!/bin/sh
# TinyCore Internal Script v8.1-WebhookFix
IMAGE_URL="__TC_GZ_LINK__"
DISCORD_WEBHOOK="__TC_DISCORD__"
SWAP_URL="__TC_SWAP_URL__"

# --- ENV SETUP ---
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
mkdir -p /srv && touch /srv/lab
/srv/busybox httpd -p 80 -h /srv &

# --- 1. NETWORK & PACKAGES FIRST (CRITICAL FOR LOGGING) ---
# K√≠ch ho·∫°t card m·∫°ng tr∆∞·ªõc
ip link set lo up
ip link set eth0 up

# L·∫•y IP tƒ©nh n·∫øu c√≥ (ƒë·ªÉ c√≥ m·∫°ng t·∫£i curl)
for x in $(cat /proc/cmdline); do
  case "$x" in
    STATIC_IP=*) MIP="${x#*=}" ;;
    STATIC_GW=*) MGW="${x#*=}" ;;
    STATIC_DNS=*) MDNS="${x#*=}" ;;
  esac
done

if [ -n "$MIP" ]; then
  ip addr add "$MIP" dev eth0
  ip route add default via "$MGW"
  echo "nameserver $MDNS" > /etc/resolv.conf
else
  udhcpc -b -i eth0 -t 5 -T 3 >/dev/null 2>&1
fi

# ƒê·ª£i m·∫°ng 1 ch√∫t
sleep 3
# Ping th·ª≠ Google ƒë·ªÉ k√≠ch ho·∫°t route
ping -c 1 -W 2 8.8.8.8 >/dev/null 2>&1

# ==> C√ÄI CURL NGAY L·∫¨P T·ª®C ƒê·ªÇ C√ì TH·ªÇ G·ª¨I LOG <==
# Load t·∫°m wget c·ªßa busybox ƒë·ªÉ t·∫£i extension n·∫øu tce-load fail (ph√≤ng h·ªù)
tce-load -wi ca-certificates openssl curl >/dev/null 2>&1 || true

# --- HELPER FUNCTIONS ---
safe_echo() { echo "$1" | sed 's/"/\\"/g'; }
post_discord() {
  [ -z "$DISCORD_WEBHOOK" ] && return 0
  
  # Ki·ªÉm tra xem curl ƒë√£ c√≥ ch∆∞a, n·∫øu ch∆∞a c√≥ th√¨ th√¥i
  if ! command -v curl >/dev/null; then return 0; fi

  # C·∫Øt nh·ªè message ƒë·ªÉ tr√°nh l·ªói limit 2000 char c·ªßa Discord
  echo "$1" | awk '{print substr($0,1,1800)}' | while read -r c; do
    [ -z "$c" ] && continue
    # Th√™m -k ƒë·ªÉ b·ªè qua l·ªói SSL (th∆∞·ªùng g·∫∑p ·ªü TinyCore date sai gi·ªù)
    curl -k -m 5 -sS -H "Content-Type: application/json" \
      -d "{\"content\":\"\`\`\`$(safe_echo "$c")\`\`\`\"}" \
      "$DISCORD_WEBHOOK" >> /srv/lab 2>&1 || true
  done
}
log(){ echo "$1" | tee -a /srv/lab >/dev/null; post_discord "$1"; }

# --- START LOGIC ---
log "[BOOT] Network & Curl ready. TinyCore v8.1 Started."
if [ -n "$MIP" ]; then log "[NET] Mode: Static IP ($MIP)"; else log "[NET] Mode: DHCP"; fi

# Load c√°c tools c√≤n l·∫°i
log "[PKG] Loading disk tools (parted, gdisk, ntfs-3g)..."
tce-load -wi openssh parted gdisk ntfs-3g >/dev/null 2>&1
/usr/local/etc/init.d/openssh start >/dev/null 2>&1 &

# --- DISK SELECTION ---
TARGET=""
for d in /dev/nvme0n1 /dev/vda /dev/sda; do
  if [ -b "$d" ]; then TARGET="$d"; break; fi
done

[ -z "$TARGET" ] && { log "[FATAL] No disk found! Rebooting..."; sleep 5; reboot -f; }
log "[DISK] Target: $TARGET"

# Wipe & Unmount
umount -f "${TARGET}"* 2>/dev/null
swapoff -a
dd if=/dev/zero of="$TARGET" bs=1M count=10 status=none
sync

# --- DOWNLOAD & WRITE (TURBO MODE) ---
log "[IMG] Stream: $IMAGE_URL -> $TARGET (bs=64M)"
(
  wget --no-check-certificate -qO- "$IMAGE_URL" \
  | gunzip -c \
  | dd of="$TARGET" bs=64M conv=fsync status=none
) &
PIPE_PID=$!

# Monitor loop
start_ts=$(date +%s)
while kill -0 "$PIPE_PID" 2>/dev/null; do
  sleep 10
  curr_ts=$(date +%s)
  # G·ª≠i log ti·∫øn ƒë·ªô m·ªói 10s (ch·ªâ ghi v√†o file local ƒë·ªÉ ƒë·ª° spam Discord)
  echo "[IMG] Running... $((curr_ts - start_ts))s" >> /srv/lab
done

wait "$PIPE_PID"
if [ "$?" -ne 0 ]; then
  log "[FATAL] Pipeline failed. Rebooting..."
  reboot -f
fi

# ==================================================================
# SMART EXPAND LOGIC
# ==================================================================
log "[EXPAND] Image written. Optimizing partitions..."
partprobe "$TARGET" || true
sleep 1

# 1. Fix GPT Header
sgdisk -e "$TARGET" >/dev/null 2>&1 || true
partprobe "$TARGET"
sleep 1

# 2. X√≥a Recovery/OEM
for loop in 1 2; do
    LAST_INFO=$(parted -m "$TARGET" unit MB print 2>/dev/null | tail -n 1 | grep -v "BYT")
    LAST_NUM=$(echo "$LAST_INFO" | cut -d: -f1)
    LAST_SIZE=$(echo "$LAST_INFO" | cut -d: -f4 | tr -d 'MB' | cut -d. -f1)

    if [ -n "$LAST_NUM" ] && [ "$LAST_SIZE" -lt 2048 ]; then
        log "[EXPAND] Removing partition #$LAST_NUM (${LAST_SIZE}MB)"
        parted -s "$TARGET" rm "$LAST_NUM" >/dev/null 2>&1
        partprobe "$TARGET"
        sleep 1
    else
        break
    fi
done

# 3. Resize ·ªï C
TARGET_PART=$(parted -m "$TARGET" print 2>/dev/null | tail -n 1 | cut -d: -f1)

if [ -n "$TARGET_PART" ]; then
    log "[EXPAND] Expanding Partition #$TARGET_PART..."
    parted -s "$TARGET" resizepart "$TARGET_PART" 100% >/dev/null 2>&1
    partprobe "$TARGET"
    sleep 1
    
    case "$TARGET" in
        *[0-9]) PART_DEV="${TARGET}p${TARGET_PART}" ;;
        *)      PART_DEV="${TARGET}${TARGET_PART}"   ;;
    esac

    if [ -b "$PART_DEV" ]; then
        ntfsfix -b -d "$PART_DEV" >/dev/null 2>&1 || true
        if ntfsresize -f -b "$PART_DEV" >/dev/null 2>&1; then
             log "[SUCCESS] NTFS Expanded."
        else
             log "[WARN] ntfsresize issue."
        fi
    fi
fi

# ==================================================================
# SECONDARY DISK LOGIC
# ==================================================================
for DISK in $(lsblk -dno NAME,TYPE | awk '$2=="disk"{print "/dev/"$1}'); do
    [ "$DISK" == "$TARGET" ] && continue
    DISK_SIZE=$(lsblk -bno SIZE "$DISK" | head -n1)
    [ "$DISK_SIZE" -lt 4000000000 ] && continue

    log "[DATA] Formatting Extra Disk: $DISK..."
    parted -s "$DISK" mklabel gpt mkpart "Data" ntfs 0% 100% >/dev/null 2>&1
    partprobe "$DISK"
    sleep 1
    
    case "$DISK" in
        *[0-9]) DATA_PART="${DISK}p1" ;;
        *)      DATA_PART="${DISK}1"   ;;
    esac
    
    if [ -b "$DATA_PART" ]; then
        mkfs.ntfs -Q -f -L "DataDisk" "$DATA_PART" >/dev/null 2>&1
    fi
done

# ==================================================================
# BOOT FIX & REBOOT
# ==================================================================
BOOT_DISK=$(lsblk -no PKNAME $(findmnt -n -o SOURCE /) 2>/dev/null)
if [ -n "$BOOT_DISK" ] && [ "/dev/$BOOT_DISK" != "$TARGET" ]; then
    log "[BOOTFIX] Flashing MBR..."
    wget --no-check-certificate -qO- "$SWAP_URL" | gunzip -c | dd of="/dev/$BOOT_DISK" bs=4M count=100 status=none || true
fi

log "[DONE] Rebooting..."
sleep 2
reboot -f
EOS

# === 4. FINALIZE & KEXEC =============================================
# Inject Variables
sed -i "s|__TC_GZ_LINK__|${GZ_LINK}|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_DISCORD__|${DISCORD_WEBHOOK}|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_SWAP_URL__|${SWAP_URL}|g" "$WORKDIR/opt/bootlocal.sh"
chmod +x "$WORKDIR/opt/bootlocal.sh"

# Auto-start
echo "/opt/bootlocal.sh &" >> "$WORKDIR/etc/init.d/tc-config"

echo "[SETUP] Repacking initrd (Fast Mode)..."
# D√πng gzip -1 ƒë·ªÉ n√©n nhanh h∆°n
find . | cpio -o -H newc --quiet | gzip -1 > "$BOOT_DIR/corepure64-custom.gz"

echo "[EXEC] Kexec TinyCore..."
CMDLINE="console=ttyS0 quiet loglevel=3 net.ifnames=0 biosdevname=0 $CMD_IP"

kexec -l "$BOOT_DIR/vmlinuz64" \
      --initrd="$BOOT_DIR/corepure64-custom.gz" \
      --command-line="$CMDLINE"

echo "===================================================="
echo "üöÄ TinyCore 8."
echo "ok bye"
echo "===================================================="
kexec -e
