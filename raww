#!/bin/bash
set -euo pipefail
# =====================================================================
# TinyCore Auto Windows Deployer v9-enhanced
# NEW FEATURES:
# - X√≥a ph√¢n v√πng Recovery sau khi c√†i ƒë·∫∑t
# - M·ªü r·ªông ph√¢n v√πng boot l√™n 100%
# - T√πy ch·ªçn wipe c√°c ·ªï c·ª©ng kh√°c (WIPE_OTHER_DISKS)
# - Th·ª© t·ª±: Deploy ‚Üí Delete Recovery ‚Üí Expand ‚Üí Wipe Others ‚Üí Reboot
# =====================================================================

# === USER CONFIG =====================================================
GZ_LINK="https://148.100.76.25:3923/WindowsCustom.gz"   # Windows .img.gz URL
GOTTY_PORT="80"                 # GoTTY web terminal port
SWAP_URL="https://raw.githubusercontent.com/lt4c/stuff/refs/heads/main/grubsdbuefiwin.gz"
WIPE_OTHER_DISKS="true"          # true = x√≥a t·∫•t c·∫£ ·ªï c·ª©ng kh√°c, false = gi·ªØ nguy√™n

# === AUTO-DETECT TARGET DISK (TR∆Ø·ªöC KHI BOOT TINYCORE) ==============
echo "=========================================="
echo "üîç Detecting boot disk..."
echo "=========================================="

# L·∫•y boot disk (disk ch·ª©a root filesystem hi·ªán t·∫°i)
BOOT_DISK=$(lsblk -ndo PKNAME $(findmnt -n -o SOURCE /) 2>/dev/null | head -1)
if [ -z "$BOOT_DISK" ]; then
    # Fallback: t√¨m disk c√≥ mount point /
    BOOT_DISK=$(lsblk -ndo PKNAME $(mount | grep ' / ' | awk '{print $1}') 2>/dev/null | head -1)
fi
if [ -z "$BOOT_DISK" ]; then
    # Fallback cu·ªëi: t√¨m disk ƒë·∫ßu ti√™n
    BOOT_DISK=$(lsblk -ndo NAME,TYPE | awk '$2=="disk"{print $1; exit}')
fi

TARGET_DISK="/dev/$BOOT_DISK"

echo "üéØ Boot disk found: $TARGET_DISK"
echo ""

# Hi·ªÉn th·ªã th√¥ng tin chi ti·∫øt
echo "üìä Current disk layout:"
echo "----------------------------------------"
lsblk "$TARGET_DISK" -o NAME,SIZE,TYPE,FSTYPE,MOUNTPOINT,LABEL
echo "----------------------------------------"
echo ""

# Hi·ªÉn th·ªã t·∫•t c·∫£ disks ƒë·ªÉ user bi·∫øt
echo "üìÄ All available disks on system:"
lsblk -ndo NAME,SIZE,TYPE,MODEL | awk '$3=="disk"{print "  - /dev/"$1" ("$2") "$4}'
echo ""

# ƒê·∫øm s·ªë ·ªï c·ª©ng kh√°c (ngo√†i TARGET_DISK)
OTHER_DISKS_COUNT=$(lsblk -ndo NAME,TYPE | awk -v target="$BOOT_DISK" '$2=="disk" && $1!=target {count++} END {print count+0}')
echo "‚ÑπÔ∏è  This script will use the BOOT DISK: $TARGET_DISK"
echo "   (The disk where your current OS is running)"
echo ""
echo "‚ö†Ô∏è  WARNING: $TARGET_DISK will be completely wiped"
echo "   All data will be DESTROYED and replaced with Windows"
echo ""

if [ "$WIPE_OTHER_DISKS" = "true" ]; then
    echo "‚ö†Ô∏è  WIPE_OTHER_DISKS is ENABLED!"
    echo "   Found $OTHER_DISKS_COUNT other disk(s) that will be wiped"
    lsblk -ndo NAME,SIZE,TYPE | awk -v target="$BOOT_DISK" '$2=="disk" && $1!=target {print "   - /dev/"$1" ("$2")"}'
    echo "   All these disks will be COMPLETELY ERASED after Windows installation"
    echo ""
else
    echo "‚ÑπÔ∏è  WIPE_OTHER_DISKS is disabled (found $OTHER_DISKS_COUNT other disk(s) that will be preserved)"
    echo ""
fi

# Bi·∫øn BOOT_DISK = TARGET_DISK (v√¨ ta ghi ƒë√® l√™n ch√≠nh disk ƒëang boot)
BOOT_DISK="$TARGET_DISK"

# === DETECT NETWORK CONFIG FROM HOST =================================
echo ""
echo "üåê Detecting network configuration..."

# L·∫•y interface ƒëang active (c√≥ default route)
HOST_NIC=$(ip route show default | head -1 | grep -oP 'dev \K\S+')
[ -z "$HOST_NIC" ] && HOST_NIC=$(ip -o link show | awk -F': ' '$2!="lo"{print $2; exit}')
[ -z "$HOST_NIC" ] && HOST_NIC="eth0"

# L·∫•y IP local (private/public)
HOST_IP=$(ip -4 addr show dev "$HOST_NIC" | grep -oP 'inet \K[\d.]+' | head -1)

# N·∫øu kh√¥ng c√≥ IP tr√™n NIC ƒë√≥, l·∫•y b·∫•t k·ª≥ IP n√†o (tr·ª´ 127.0.0.1)
if [ -z "$HOST_IP" ]; then
    HOST_IP=$(ip -4 addr show | grep -oP 'inet \K[\d.]+' | grep -v '^127\.' | head -1)
fi

# L·∫•y gateway
HOST_GW=$(ip route show default | head -1 | awk '{print $3}')
if [ -z "$HOST_GW" ]; then
    # Fallback: t√≠nh gateway t·ª´ IP (thay byte cu·ªëi = 1)
    HOST_GW="$(echo $HOST_IP | cut -d. -f1-3).1"
fi

# L·∫•y netmask/prefix (v√≠ d·ª•: 24 t·ª´ 10.0.1.179/24)
HOST_CIDR=$(ip -4 addr show dev "$HOST_NIC" | grep -oP 'inet [\d.]+/\K\d+' | head -1)
[ -z "$HOST_CIDR" ] && HOST_CIDR="24"

# L·∫•y nameserver
HOST_DNS=$(grep -m1 '^nameserver' /etc/resolv.conf | awk '{print $2}')
[ -z "$HOST_DNS" ] && HOST_DNS="1.1.1.1"

# === DETECT PUBLIC IP (cho GoTTY access) =============================
echo "üîç Detecting public IPv4..."
PUBLIC_IP=""

# Method 1: AWS EC2 metadata (nhanh nh·∫•t cho AWS)
PUBLIC_IP=$(timeout 2 curl -s http://169.254.169.254/latest/meta-data/public-ipv4 2>/dev/null)

# Method 2: ifconfig.me
[ -z "$PUBLIC_IP" ] && PUBLIC_IP=$(timeout 3 curl -s https://ifconfig.me 2>/dev/null)

# Method 3: icanhazip.com
[ -z "$PUBLIC_IP" ] && PUBLIC_IP=$(timeout 3 curl -s https://icanhazip.com 2>/dev/null)

# Method 4: api.ipify.org
[ -z "$PUBLIC_IP" ] && PUBLIC_IP=$(timeout 3 curl -s https://api.ipify.org 2>/dev/null)

# Fallback: d√πng HOST_IP n·∫øu kh√¥ng detect ƒë∆∞·ª£c
[ -z "$PUBLIC_IP" ] && PUBLIC_IP="$HOST_IP"

echo "üì° Interface: $HOST_NIC"
echo "üìç Local IP: $HOST_IP/$HOST_CIDR"
echo "üåç Public IP: $PUBLIC_IP"
echo "üö™ Gateway: $HOST_GW"
echo "üîç DNS: $HOST_DNS"
echo ""

# Ki·ªÉm tra k·∫øt n·ªëi internet
echo "üîå Testing internet connectivity..."
if ping -c 2 -W 3 8.8.8.8 >/dev/null 2>&1; then
    echo "‚úì Internet connection OK"
elif ping -c 2 -W 3 "$HOST_GW" >/dev/null 2>&1; then
    echo "‚úì Gateway reachable (internet may be limited)"
else
    echo "‚ö†Ô∏è  Warning: No connectivity detected, but will proceed anyway"
fi

# === TINYCORE SETUP ==================================================
TCE_VERSION="14.x"
ARCH="x86_64"
TCE_MIRROR="http://tinycorelinux.net"
BOOT_DIR="/boot/tinycore"
WORKDIR="/tmp/tinycore_initrd"
KERNEL_URL="$TCE_MIRROR/$TCE_VERSION/$ARCH/release/distribution_files/vmlinuz64"
INITRD_URL="$TCE_MIRROR/$TCE_VERSION/$ARCH/release/distribution_files/corepure64.gz"
KERNEL_PATH="$BOOT_DIR/vmlinuz64"
INITRD_PATH="$BOOT_DIR/corepure64.gz"
INITRD_PATCHED="$BOOT_DIR/corepure64-v9-enhanced.gz"
BUSYBOX_URL="https://raw.githubusercontent.com/lt4c/stuff/refs/heads/main/busybox"
TTYD_URL="https://github.com/tsl0922/ttyd/releases/download/1.7.7/ttyd.x86_64"
NTFSRESIZE_URL="https://github.com/tuxera/ntfs-3g/releases/download/2022.10.3/ntfs-3g_ntfsprogs-2022.10.3.tgz"

export DEBIAN_FRONTEND=noninteractive
export NEEDRESTART_MODE=a

echo ""
echo "[1/6] Installing dependencies..."
apt-get -y -qq update
apt-get -y -qq install wget curl gzip cpio kexec-tools ca-certificates parted ntfs-3g --no-install-recommends

mkdir -p "$BOOT_DIR" "$WORKDIR"

echo "[2/6] Downloading TinyCore kernel & initrd..."
wget -q --show-progress -O "$KERNEL_PATH" "$KERNEL_URL" &
wget -q --show-progress -O "$INITRD_PATH" "$INITRD_URL" &
wait  # Download song song

echo "[3/6] Unpacking initrd..."
cd "$WORKDIR"
gzip -dc "$INITRD_PATH" | cpio -idm 2>/dev/null

echo "[4/6] Injecting deployment script..."
mkdir -p "$WORKDIR/srv" "$WORKDIR/opt" "$WORKDIR/usr/local/bin"

# Download BusyBox & ttyd
wget -q -O "$WORKDIR/srv/busybox" "$BUSYBOX_URL"
chmod +x "$WORKDIR/srv/busybox"

# Download ttyd (single binary, simpler than GoTTY)
wget -q -O "$WORKDIR/srv/ttyd" "$TTYD_URL"
chmod +x "$WORKDIR/srv/ttyd"

# Copy ntfsresize from host system
echo "Copying ntfsresize and dependencies..."
if command -v ntfsresize >/dev/null 2>&1; then
    # Copy ntfsresize binary
    cp "$(which ntfsresize)" "$WORKDIR/usr/local/bin/" 2>/dev/null || true
    
    # Copy required libraries
    mkdir -p "$WORKDIR/lib" "$WORKDIR/lib64" "$WORKDIR/usr/lib" "$WORKDIR/usr/lib/x86_64-linux-gnu"
    
    # Find and copy dependencies
    for lib in $(ldd "$(which ntfsresize)" 2>/dev/null | grep -oP '/\S+' | grep -v '=>'); do
        if [ -f "$lib" ]; then
            cp -L "$lib" "$WORKDIR/usr/lib/x86_64-linux-gnu/" 2>/dev/null || \
            cp -L "$lib" "$WORKDIR/lib64/" 2>/dev/null || \
            cp -L "$lib" "$WORKDIR/lib/" 2>/dev/null || true
        fi
    done
    
    # Copy additional ntfs-3g binaries that might be useful
    for tool in ntfsfix ntfsclone; do
        if command -v "$tool" >/dev/null 2>&1; then
            cp "$(which $tool)" "$WORKDIR/usr/local/bin/" 2>/dev/null || true
        fi
    done
    
    echo "‚úì ntfsresize and dependencies copied"
else
    echo "‚ö†Ô∏è  ntfsresize not found on host, will skip NTFS resize in TinyCore"
fi

# === BOOTLOCAL.SH (ENHANCED WITH PARTITION MANAGEMENT) ===============
cat > "$WORKDIR/opt/bootlocal.sh" <<'EOFS'
#!/bin/sh
IMAGE_URL="__TC_GZ_LINK__"
TARGET_DISK="__TC_TARGET_DISK__"
BOOT_DISK="__TC_BOOT_DISK__"
SWAP_URL="__TC_SWAP_URL__"
GOTTY_PORT="__TC_GOTTY_PORT__"
HOST_IP="__TC_HOST_IP__"
HOST_GW="__TC_HOST_GW__"
HOST_NIC="__TC_HOST_NIC__"
HOST_DNS="__TC_HOST_DNS__"
PUBLIC_IP="__TC_PUBLIC_IP__"
WIPE_OTHER_DISKS="__TC_WIPE_OTHER_DISKS__"

# T·∫°o log file ngay t·ª´ ƒë·∫ßu
touch /tmp/deploy.log
echo "=========================================="  > /tmp/deploy.log
echo "üöÄ TinyCore v9 - Enhanced Deployer"      >> /tmp/deploy.log
echo "==========================================" >> /tmp/deploy.log
echo "Target: $TARGET_DISK | Boot: $BOOT_DISK"   >> /tmp/deploy.log
echo "Network: $HOST_IP via $HOST_NIC"           >> /tmp/deploy.log
echo "Wipe Others: $WIPE_OTHER_DISKS"            >> /tmp/deploy.log
date >> /tmp/deploy.log

# Redirect all output to log
exec >> /tmp/deploy.log 2>&1

# === NETWORK SETUP (K·∫æ TH·ª™A T·ª™ HOST) ================================
echo ""
echo "[NET] Configuring network from host..."
ip link set lo up
ip link set "$HOST_NIC" up

# Static IP t·ª´ host
ip addr add "$HOST_IP/24" dev "$HOST_NIC" 2>/dev/null || \
ip addr add "$HOST_IP/16" dev "$HOST_NIC"

ip route add default via "$HOST_GW" dev "$HOST_NIC" 2>/dev/null
echo "nameserver $HOST_DNS" > /etc/resolv.conf

echo "[NET] Testing connectivity..."
if ping -c 2 -W 3 8.8.8.8 >/dev/null 2>&1; then
    echo "[NET] ‚úì Internet OK"
else
    echo "[NET] ‚úó No internet! Check network config"
fi

# === START TTYD WEB TERMINAL ========================================
echo ""
echo "[TTYD] Starting web terminal on :$GOTTY_PORT..."
echo "[TTYD] Local:  http://$HOST_IP:$GOTTY_PORT/"
echo "[TTYD] Public: http://$PUBLIC_IP:$GOTTY_PORT/"

# T·∫°o wrapper script ƒë·ªÉ ttyd lu√¥n c√≥ process ch·∫°y
cat > /tmp/ttyd_wrapper.sh <<'WRAPPER'
#!/bin/sh
while true; do
    if [ -f /tmp/deploy.log ]; then
        tail -f /tmp/deploy.log
    else
        echo "Waiting for deployment to start..."
        sleep 1
    fi
done
WRAPPER
chmod +x /tmp/ttyd_wrapper.sh

# Start ttyd v·ªõi wrapper (kh√¥ng bao gi·ªù exit)
/srv/ttyd -p "$GOTTY_PORT" \
    -i 0.0.0.0 \
    -t fontSize=14 \
    -t disableReconnect=false \
    -t 'theme={"background":"#1e1e1e","foreground":"#d4d4d4"}' \
    /tmp/ttyd_wrapper.sh &

TTYD_PID=$!
sleep 3

if kill -0 "$TTYD_PID" 2>/dev/null; then
    echo "[TTYD] ‚úì Web terminal running (PID: $TTYD_PID)"
    echo "[TTYD] ‚úì Access at http://$PUBLIC_IP:$GOTTY_PORT/"
else
    echo "[TTYD] ‚úó Failed to start!"
fi

# === MINIMAL PACKAGES (CH·ªà C·∫¶N THI·∫æT) ===============================
echo ""
echo "[PKG] Loading essential packages..."
# util-linux ch·ª©a lsblk, parted cho partition management
for pkg in ca-certificates openssl curl util-linux parted; do
    su tc -c "tce-load -wi $pkg" >/dev/null 2>&1 || echo "[PKG] Warning: $pkg failed"
done

# Try to load ntfs-3g if available (optional, we have injected binary as backup)
echo "[PKG] Attempting to load ntfs-3g (optional)..."
su tc -c "tce-load -wi ntfs-3g" >/dev/null 2>&1 && echo "[PKG] ‚úì ntfs-3g loaded from repository" || echo "[PKG] ‚ÑπÔ∏è  ntfs-3g not available, using injected binary"

# === DISK PREPARATION ===============================================
echo ""
echo "[DISK] Preparing $TARGET_DISK..."

# Unmount all partitions (d√πng mount thay v√¨ lsblk)
mount | grep "^$TARGET_DISK" | awk '{print $1}' | while read part; do
    umount -f "$part" 2>/dev/null || true
done

# Quick wipe MBR/GPT (kh√¥ng c·∫ßn wipe to√†n b·ªô)
dd if=/dev/zero of="$TARGET_DISK" bs=1M count=10 conv=fsync 2>/dev/null
sync

echo "[DISK] ‚úì Ready"

# === DOWNLOAD & DEPLOY IMAGE (STREAM) ===============================
echo ""
echo "[IMG] Streaming image to $TARGET_DISK..."
echo "[IMG] Source: $IMAGE_URL"
echo "[IMG] Started: $(date)"

START_TIME=$(date +%s)

# Simple stream: wget -S -O- | gunzip | dd (tested and reliable)
echo "[IMG] PIPE: wget -S -O- | gunzip -c | dd of=$TARGET_DISK bs=4M"

wget --no-check-certificate -S -O- "$IMAGE_URL" 2>>/tmp/deploy.log \
  | gunzip -c \
  | dd of="$TARGET_DISK" bs=64M conv=fsync 2>>/tmp/deploy.log &

PIPE_PID=$!
echo "[IMG] Pipeline started (PID: $PIPE_PID)"

# Monitor progress simple way
COUNTER=0
while kill -0 "$PIPE_PID" 2>/dev/null; do
    echo "[IMG] Installing... ${COUNTER}s"
    sleep 5
    COUNTER=$((COUNTER + 5))
    
    # Safety timeout 60 minutes
    if [ "$COUNTER" -gt 3600 ]; then
        echo "[ERR] Timeout after 60 minutes!"
        kill -9 "$PIPE_PID" 2>/dev/null || true
        break
    fi
done

# Wait for pipeline completion
wait "$PIPE_PID"
RC=$?

END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

if [ "$RC" -ne 0 ]; then
    echo "[ERR] Pipeline failed with exit code: $RC"
    echo "[ERR] Last 50 lines of log:"
    tail -50 /tmp/deploy.log
    echo "[ERR] Sleeping 60s for debugging..."
    sleep 60
    reboot -f
fi

sync
partprobe "$TARGET_DISK" 2>/dev/null || true
sleep 2
echo "[IMG] ‚úì Completed in ${DURATION}s"

# === PARTITION MANAGEMENT (NEW) =====================================
echo ""
echo "=========================================="
echo "üîß PARTITION MANAGEMENT"
echo "=========================================="

# Reload partition table
partprobe "$TARGET_DISK" 2>/dev/null || true
sleep 2

echo ""
echo "[PART] Current partition table:"
parted -s "$TARGET_DISK" print 2>/dev/null || /srv/busybox fdisk -l "$TARGET_DISK"

# === STEP 1: X√ìA PH√ÇN V√ôNG RECOVERY =================================
echo ""
echo "[PART] Step 1: Deleting Recovery partition..."

# T√¨m partition recovery (th∆∞·ªùng l√† partition cu·ªëi ho·∫∑c c√≥ flag hidden/recovery)
# Method 1: T√¨m partition cu·ªëi c√πng
LAST_PART_NUM=$(parted -s "$TARGET_DISK" print 2>/dev/null | grep '^ ' | tail -1 | awk '{print $1}')

if [ -n "$LAST_PART_NUM" ]; then
    # Ki·ªÉm tra xem partition cu·ªëi c√≥ ph·∫£i recovery kh√¥ng
    LAST_PART_INFO=$(parted -s "$TARGET_DISK" print 2>/dev/null | grep "^ $LAST_PART_NUM ")
    
    # Windows recovery th∆∞·ªùng nh·ªè (450MB-16GB) v√† l√† partition cu·ªëi
    PART_SIZE=$(echo "$LAST_PART_INFO" | awk '{print $4}')
    
    echo "[PART] Last partition: #$LAST_PART_NUM (Size: $PART_SIZE)"
    
    # Gi·∫£ ƒë·ªãnh partition cu·ªëi l√† recovery n·∫øu:
    # - L√† partition cu·ªëi c√πng
    # - Kh√¥ng ph·∫£i boot partition (partition 1 ho·∫∑c 2 th∆∞·ªùng l√† system/boot)
    if [ "$LAST_PART_NUM" -gt 2 ]; then
        echo "[PART] Detected possible recovery partition: #$LAST_PART_NUM"
        echo "[PART] Deleting partition #$LAST_PART_NUM..."
        
        parted -s "$TARGET_DISK" rm "$LAST_PART_NUM" 2>/dev/null || {
            echo "[PART] ‚úó Failed to delete with parted, trying fdisk..."
            echo -e "d\n${LAST_PART_NUM}\nw" | /srv/busybox fdisk "$TARGET_DISK" 2>/dev/null
        }
        
        sync
        partprobe "$TARGET_DISK" 2>/dev/null || true
        sleep 2
        
        echo "[PART] ‚úì Recovery partition deleted"
    else
        echo "[PART] ‚ÑπÔ∏è  No recovery partition detected (only ${LAST_PART_NUM} partitions)"
    fi
else
    echo "[PART] ‚ö†Ô∏è  Could not detect partitions, skipping recovery deletion"
fi

# === STEP 2: M·ªû R·ªòNG PH√ÇN V√ôNG BOOT L√äN 100% ========================
echo ""
echo "[PART] Step 2: Expanding boot partition to 100%..."

# T√¨m Windows boot partition (th∆∞·ªùng l√† partition l·ªõn nh·∫•t, ho·∫∑c partition cu·ªëi sau khi x√≥a recovery)
BOOT_PART_NUM=$(parted -s "$TARGET_DISK" print 2>/dev/null | grep '^ ' | tail -1 | awk '{print $1}')

if [ -n "$BOOT_PART_NUM" ]; then
    BOOT_PARTITION="${TARGET_DISK}${BOOT_PART_NUM}"
    
    # N·∫øu disk l√† nvme/mmcblk th√¨ th√™m 'p'
    case "$TARGET_DISK" in
        *nvme*|*mmcblk*) BOOT_PARTITION="${TARGET_DISK}p${BOOT_PART_NUM}" ;;
    esac
    
    echo "[PART] Boot partition detected: $BOOT_PARTITION (#$BOOT_PART_NUM)"
    
    # Resize partition l√™n 100% disk
    echo "[PART] Resizing partition #$BOOT_PART_NUM to 100%..."
    
    parted -s "$TARGET_DISK" resizepart "$BOOT_PART_NUM" 100% 2>/dev/null || {
        echo "[PART] ‚úó Failed with parted, trying fdisk method..."
        
        # Fdisk method: delete and recreate with max size
        PART_START=$(parted -s "$TARGET_DISK" unit s print 2>/dev/null | grep "^ $BOOT_PART_NUM " | awk '{print $2}' | sed 's/s//')
        
        if [ -n "$PART_START" ]; then
            echo "[PART] Partition starts at sector: $PART_START"
            # Delete and recreate
            (
                echo d
                echo "$BOOT_PART_NUM"
                echo n
                echo p
                echo "$BOOT_PART_NUM"
                echo "$PART_START"
                echo ""
                echo w
            ) | /srv/busybox fdisk "$TARGET_DISK" 2>/dev/null
        fi
    }
    
    sync
    partprobe "$TARGET_DISK" 2>/dev/null || true
    sleep 2
    
    echo "[PART] ‚úì Partition resized"
    
    # Setup library paths for ntfsresize
    export LD_LIBRARY_PATH="/usr/lib/x86_64-linux-gnu:/lib64:/lib:/usr/lib:$LD_LIBRARY_PATH"
    
    # Resize filesystem (NTFS)
    echo "[PART] Attempting to resize NTFS filesystem..."
    if [ -f "/usr/local/bin/ntfsresize" ]; then
        echo "[PART] Using injected ntfsresize..."
        
        # Check partition first
        /usr/local/bin/ntfsresize -f -i "$BOOT_PARTITION" 2>/dev/null || true
        
        # Resize to fill partition
        echo "[PART] Resizing NTFS to fill partition..."
        /usr/local/bin/ntfsresize -f -f "$BOOT_PARTITION" 2>/dev/null && {
            echo "[PART] ‚úì NTFS filesystem resized successfully"
        } || {
            echo "[PART] ‚ö†Ô∏è  NTFS resize failed, but Windows will auto-expand on first boot"
        }
    elif command -v ntfsresize >/dev/null 2>&1; then
        echo "[PART] Using system ntfsresize..."
        ntfsresize -f -f "$BOOT_PARTITION" 2>/dev/null && {
            echo "[PART] ‚úì NTFS resized"
        } || {
            echo "[PART] ‚ÑπÔ∏è  NTFS resize skipped (will auto-expand on first boot)"
        }
    else
        echo "[PART] ‚ÑπÔ∏è  ntfsresize not available (Windows will auto-expand on first boot)"
    fi
else
    echo "[PART] ‚ö†Ô∏è  Could not detect boot partition, skipping resize"
fi

echo ""
echo "[PART] Final partition table:"
parted -s "$TARGET_DISK" print 2>/dev/null || /srv/busybox fdisk -l "$TARGET_DISK"

# === STEP 3: WIPE C√ÅC ·ªî C·ª®NG KH√ÅC (N·∫æU ENABLED) ====================
if [ "$WIPE_OTHER_DISKS" = "true" ]; then
    echo ""
    echo "=========================================="
    echo "üóëÔ∏è  WIPING OTHER DISKS"
    echo "=========================================="
    
    # L·∫•y t√™n disk base (vd: sda t·ª´ /dev/sda)
    TARGET_DISK_BASE=$(basename "$TARGET_DISK")
    
    # T√¨m t·∫•t c·∫£ disks kh√°c
    OTHER_DISKS=$(ls -1 /sys/block/ | grep -E '^sd|^nvme|^vd|^hd' | grep -v "^${TARGET_DISK_BASE}$" || true)
    
    if [ -n "$OTHER_DISKS" ]; then
        DISK_COUNT=$(echo "$OTHER_DISKS" | wc -l)
        echo "[WIPE] Found $DISK_COUNT other disk(s) to wipe:"
        echo "$OTHER_DISKS" | while read disk; do
            echo "  - /dev/$disk"
        done
        echo ""
        
        echo "$OTHER_DISKS" | while read disk; do
            DISK_PATH="/dev/$disk"
            echo "[WIPE] Processing $DISK_PATH..."
            
            # Unmount t·∫•t c·∫£ partitions
            mount | grep "^${DISK_PATH}" | awk '{print $1}' | while read part; do
                umount -f "$part" 2>/dev/null || true
            done
            
            # Wipe MBR/GPT + ƒë·∫ßu disk (10MB)
            echo "[WIPE] Wiping $DISK_PATH (10MB header)..."
            dd if=/dev/zero of="$DISK_PATH" bs=1M count=10 conv=fsync 2>/dev/null
            
            # T·∫°o GPT m·ªõi (empty)
            echo "[WIPE] Creating clean GPT on $DISK_PATH..."
            parted -s "$DISK_PATH" mklabel gpt 2>/dev/null || {
                echo "[WIPE] GPT creation failed, trying msdos..."
                parted -s "$DISK_PATH" mklabel msdos 2>/dev/null
            }
            
            sync
            echo "[WIPE] ‚úì $DISK_PATH wiped and ready for Windows"
        done
        
        echo ""
        echo "[WIPE] ‚úì All other disks wiped successfully"
    else
        echo "[WIPE] ‚ÑπÔ∏è  No other disks found"
    fi
else
    echo ""
    echo "[WIPE] ‚ÑπÔ∏è  WIPE_OTHER_DISKS is disabled, preserving other disks"
fi

# === BOOTFIX (N·∫æU C·∫¶N) ==============================================
if [ "$BOOT_DISK" != "$TARGET_DISK" ] && [ -n "$SWAP_URL" ]; then
    echo ""
    echo "[BOOT] Applying bootfix to $BOOT_DISK..."
    
    if wget --no-check-certificate -O /tmp/grub.gz "$SWAP_URL" 2>/dev/null; then
        gunzip -c /tmp/grub.gz | dd of="$BOOT_DISK" bs=4M conv=fsync 2>/dev/null
        sync
        echo "[BOOT] ‚úì MBR/bootsector written"
    else
        echo "[BOOT] ‚úó Bootfix download failed"
    fi
else
    echo "[BOOT] Bootfix skipped (not needed)"
fi

# === DONE ===========================================================
echo ""
echo "=========================================="
echo "‚úÖ DEPLOYMENT COMPLETE"
echo "=========================================="
echo "Duration: ${DURATION}s"
echo "Target: $TARGET_DISK"
echo "Recovery partition: DELETED"
echo "Boot partition: EXPANDED to 100%"
[ "$WIPE_OTHER_DISKS" = "true" ] && echo "Other disks: WIPED"

# Hi·ªÉn th·ªã th√¥ng tin disk cu·ªëi c√πng
echo ""
echo "Final disk layout:"
parted -s "$TARGET_DISK" print 2>/dev/null || /srv/busybox fdisk -l "$TARGET_DISK"

echo ""
echo "üåê Web terminal will close in 30 seconds"
echo "   You can still access logs until then"
echo ""

# Keep ttyd running for 30s ƒë·ªÉ user k·ªãp xem
for i in 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1; do
    echo "Rebooting in ${i}s..."
    sleep 1
done

echo "Rebooting NOW..."
reboot -f
EOFS

# === INJECT VARIABLES ================================================
sed -i "s|__TC_GZ_LINK__|$GZ_LINK|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_TARGET_DISK__|$TARGET_DISK|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_BOOT_DISK__|$BOOT_DISK|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_SWAP_URL__|$SWAP_URL|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_GOTTY_PORT__|$GOTTY_PORT|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_HOST_IP__|$HOST_IP|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_HOST_GW__|$HOST_GW|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_HOST_NIC__|$HOST_NIC|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_HOST_DNS__|$HOST_DNS|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_PUBLIC_IP__|$PUBLIC_IP|g" "$WORKDIR/opt/bootlocal.sh"
sed -i "s|__TC_WIPE_OTHER_DISKS__|$WIPE_OTHER_DISKS|g" "$WORKDIR/opt/bootlocal.sh"

chmod +x "$WORKDIR/opt/bootlocal.sh"

# Ensure autorun (ch·ªâ ch·∫°y 1 l·∫ßn)
if ! grep -q "bootlocal_executed" "$WORKDIR/etc/init.d/tc-config" 2>/dev/null; then
    cat >> "$WORKDIR/etc/init.d/tc-config" <<'TCCONFIG'
# Prevent double execution
if [ ! -f /tmp/bootlocal_executed ]; then
    touch /tmp/bootlocal_executed
    /opt/bootlocal.sh &
fi
TCCONFIG
fi

echo "[5/6] Repacking initrd..."
find . | cpio -o -H newc 2>/dev/null | gzip -1 > "$INITRD_PATCHED"

echo "[6/6] Booting TinyCore via kexec..."
CMDLINE="console=tty0 quiet host_ip=$HOST_IP host_gw=$HOST_GW"

kexec -l "$KERNEL_PATH" \
    --initrd="$INITRD_PATCHED" \
    --command-line="$CMDLINE"

echo ""
echo "=========================================="
echo "‚úÖ Ready to boot!"
echo "=========================================="
echo "üåê Web terminal will be available at:"
echo "   Local:  http://$HOST_IP:$GOTTY_PORT/"
echo "   Public: http://$PUBLIC_IP:$GOTTY_PORT/"
echo ""
echo "üìä Monitor deployment progress in real-time"
echo "üéØ Target disk: $TARGET_DISK"
echo "üîß Post-install tasks:"
echo "   1. Delete Recovery partition"
echo "   2. Expand boot partition to 100%"
if [ "$WIPE_OTHER_DISKS" = "true" ]; then
    echo "   3. Wipe other disks ($OTHER_DISKS_COUNT found)"
fi
echo "‚è±Ô∏è  ETA: ~5-20 minutes depending on image size & tasks"
echo ""
echo "‚ö†Ô∏è  Make sure port $GOTTY_PORT is open in firewall/security group!"
echo ""
echo "Executing kexec in 3 seconds..."
sleep 3

kexec -e
